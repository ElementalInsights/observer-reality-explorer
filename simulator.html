<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reality Simulator - Observer Lens</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0e27;
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        /* Compact Top Bar */
        .top-bar {
            background: linear-gradient(135deg, #1a1f3a 0%, #0a0e27 100%);
            padding: 15px 20px;
            border-bottom: 2px solid #00ff88;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .top-bar h1 {
            font-size: 1.3em;
            color: #00ff88;
            margin: 0;
        }

        .top-bar a {
            color: #888;
            text-decoration: none;
            font-size: 0.9em;
            transition: color 0.2s;
        }

        .top-bar a:hover {
            color: #00ff88;
        }

        /* Main Canvas */
        .main-canvas {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 40px;
            display: grid;
            grid-template-columns: 420px 1fr 380px;
            gap: 20px;
            padding: 40px;
        }

        /* Visualization Container (center, row 2) */
        .viz-container {
            grid-column: 2;
            grid-row: 2;
            background: rgba(255,255,255,0.03);
            border-radius: 20px;
            border: 2px solid rgba(0,255,136,0.2);
            padding: 0;
            position: relative;
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        /* Math Panel (left side, row 2) */
        .math-panel {
            grid-column: 1;
            grid-row: 2;
            background: rgba(10,14,39,0.95);
            border-radius: 20px;
            border: 2px solid rgba(0,255,136,0.2);
            padding: 20px;
            backdrop-filter: blur(10px);
            overflow-y: auto;
        }

        .math-panel h2 {
            color: #00ff88;
            font-size: 1.2em;
            margin: 0 0 15px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid #00ff88;
        }

        /* Controls Panel (right side, row 2) */
        .controls-panel {
            grid-column: 3;
            grid-row: 2;
            background: rgba(10,14,39,0.95);
            border-radius: 20px;
            border: 2px solid rgba(0,255,136,0.2);
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Custom Scrollbar for Controls Panel (match math panel) */
        .controls-panel::-webkit-scrollbar {
            width: 8px;
        }

        .controls-panel::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
        }

        .controls-panel::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 4px;
        }

        .controls-panel h2 {
            color: #00ff88;
            font-size: 1.2em;
            margin: 0 0 15px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid #00ff88;
        }

        .controls-panel h2,
        .math-row h2 {
            color: #00ff88;
            font-size: 1.2em;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #00ff88;
        }

        /* Controls Section */
        .control-section {
            background: rgba(0,255,136,0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0,255,136,0.2);
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: #00ff88;
            font-size: 0.9em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .observer-select {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 12px;
        }

        .observer-select button {
            padding: 8px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            color: white;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .observer-select button:hover {
            background: rgba(255,255,255,0.1);
        }

        .observer-select button.active {
            background: #00ff88;
            color: #0a0e27;
            border-color: #00ff88;
            font-weight: 700;
        }

        .control-row {
            margin: 10px 0;
        }

        .control-row label {
            display: block;
            font-size: 1em;
            color: #aaa;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .control-row input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .control-values {
            display: flex;
            justify-content: space-between;
            font-size: 1em;
            color: #00ff88;
            font-weight: 500;
        }

        .math-section {
            margin-bottom: 25px;
        }

        .math-section h3 {
            color: #00ff88;
            font-size: 1em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .formula {
            background: rgba(0,255,136,0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #00ff88;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.8;
        }

        .formula-label {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 5px;
        }

        .formula-value {
            color: #00ff88;
            font-weight: 700;
            font-size: 1.1em;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            position: relative;
        }

        .metric-label {
            color: #aaa;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 1em;
            margin-bottom: 6px;
        }

        .metric-value {
            color: #00ff88;
            font-weight: 700;
            font-size: 1.1em;
        }

        /* Tooltip System */
        .tooltip-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background: rgba(0,255,136,0.3);
            border: 1px solid #00ff88;
            border-radius: 50%;
            text-align: center;
            line-height: 14px;
            font-size: 0.7em;
            color: #00ff88;
            cursor: help;
            position: relative;
        }

        .tooltip-icon:hover {
            background: rgba(0,255,136,0.5);
        }

        .tooltip-content {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10,14,39,0.98);
            border: 4px solid #00ff88;
            border-radius: 16px;
            padding: 40px;
            width: 700px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            z-index: 10000;
            box-shadow: 0 12px 60px rgba(0,255,136,1), 0 0 0 9999px rgba(0,0,0,0.85);
        }

        .tooltip-icon.active .tooltip-content {
            display: block;
        }

        .tooltip-content h4 {
            color: #00ff88;
            margin: 0 0 25px 0;
            font-size: 2em;
            font-weight: 700;
            text-align: center;
            border-bottom: 3px solid #00ff88;
            padding-bottom: 20px;
        }

        .tooltip-content h4::after {
            content: ' üìö';
        }

        .tooltip-content p {
            color: #eee;
            margin: 15px 0;
            font-size: 1.3em;
            line-height: 1.7;
        }

        .tooltip-content strong {
            color: #00ff88;
            font-size: 1.1em;
        }

        .tooltip-content .why {
            color: #f39c12;
            font-weight: 700;
            font-size: 1.4em;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .math-panel::-webkit-scrollbar {
            width: 8px;
        }

        .math-panel::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
        }

        .math-panel::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 4px;
        }

        /* Cascade Effect Animation */
        @keyframes cascade-pulse {
            0% {
                background: rgba(0,255,136,0.1);
                transform: scale(1);
            }
            50% {
                background: rgba(0,255,136,0.3);
                transform: scale(1.02);
            }
            100% {
                background: rgba(0,255,136,0.1);
                transform: scale(1);
            }
        }

        .cascade-active {
            animation: cascade-pulse 0.6s ease-out;
        }

        .cascade-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,255,136,0.2);
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid #00ff88;
            font-size: 0.85em;
            color: #00ff88;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .cascade-indicator.active {
            opacity: 1;
        }

        /* Heat Monitor Tooltip */
        .heat-monitor {
            cursor: help;
        }

        .heat-tooltip {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: rgba(10,14,39,0.98);
            border: 2px solid #e74c3c;
            border-radius: 10px;
            padding: 16px;
            width: 420px;
            z-index: 1000;
            margin-top: 5px;
            box-shadow: 0 4px 20px rgba(231,76,60,0.4);
        }

        .heat-monitor:hover .heat-tooltip {
            display: block;
        }

        .heat-tooltip h4 {
            color: #e74c3c;
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }

        .heat-tooltip p {
            color: #ddd;
            margin: 6px 0;
            font-size: 0.95em;
            line-height: 1.6;
        }

        .heat-tooltip .why {
            color: #f39c12;
            font-weight: 600;
            margin-top: 10px;
            font-size: 1em;
        }

        /* Collapse animation */
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* Reality Grid - Optimized! */
        #reality-canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 18px;
        }

        /* Observer Info Card (row above canvas) */
        .observer-info-card {
            grid-column: 1 / -1;
            grid-row: 1;
            background: rgba(10,14,39,0.92);
            border: 2px solid rgba(0,255,136,0.5);
            border-radius: 12px;
            padding: 20px 28px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
        }

        .observer-name {
            color: #00ff88;
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .observer-desc-inline {
            color: #00ff88;
            font-size: 1em;
            line-height: 1.5;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .observer-description {
            color: #ccc;
            font-size: 1.1em;
            line-height: 1.6;
            padding: 0;
        }

        /* Live Stats Grid */
        .live-stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .live-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(0,255,136,0.05);
            border-radius: 6px;
            border: 1px solid rgba(0,255,136,0.15);
            position: relative;
        }

        .live-stat-label {
            color: #888;
            font-size: 1em;
        }

        .live-stat-value {
            color: #00ff88;
            font-weight: 700;
            font-size: 1.1em;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 6px 0;
            position: relative;
        }

        .stat-row-hover {
            cursor: pointer;
        }

        .stat-row-hover.active {
            background: rgba(155,89,182,0.1);
        }

        .stat-tooltip {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10,14,39,0.98);
            border: 4px solid #9b59b6;
            border-radius: 16px;
            padding: 40px;
            width: 700px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            z-index: 10000;
            box-shadow: 0 12px 60px rgba(155,89,182,1), 0 0 0 9999px rgba(0,0,0,0.85);
        }

        .stat-row-hover.active .stat-tooltip {
            display: block;
        }

        .stat-tooltip h4 {
            color: #9b59b6;
            margin: 0 0 25px 0;
            font-size: 2em;
            font-weight: 700;
            text-align: center;
            border-bottom: 3px solid #9b59b6;
            padding-bottom: 20px;
        }

        .stat-tooltip h4::after {
            content: ' üìö';
        }

        .stat-tooltip p {
            color: #eee;
            margin: 15px 0;
            font-size: 1.3em;
            line-height: 1.7;
        }

        .stat-tooltip strong {
            color: #9b59b6;
            font-size: 1.1em;
        }

        .stat-tooltip .why {
            color: #f39c12;
            font-weight: 700;
            font-size: 1.4em;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .stat-label {
            color: #888;
            font-size: 0.9em;
        }

        .stat-value {
            color: #00ff88;
            font-weight: 700;
            font-size: 0.95em;
        }

        .perf-fps {
            color: #27ae60;
        }

        .perf-lod {
            color: #f39c12;
        }

        .perf-effects {
            color: #9b59b6;
        }

        .info-display p {
            color: #aaa;
            font-size: 0.85em;
            line-height: 1.6;
            margin: 5px 0;
        }

        .info-display .emphasis {
            color: #00ff88;
            font-weight: 600;
        }

        /* Heat Monitor */
        .heat-monitor {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 12px 18px;
            border-radius: 10px;
            border-left: 4px solid #e74c3c;
            min-width: 180px;
        }

        .perf-monitor {
            position: absolute;
            top: 150px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 12px 18px;
            border-radius: 10px;
            border-left: 4px solid #9b59b6;
            min-width: 180px;
            font-size: 0.85em;
        }

        .perf-monitor .perf-label {
            color: #9b59b6;
            font-weight: 700;
            margin-bottom: 6px;
        }

        .perf-monitor .perf-row {
            color: #aaa;
            margin: 4px 0;
            display: flex;
            justify-content: space-between;
        }

        .perf-monitor .perf-row .perf-value {
            color: #00ff88;
            font-weight: 600;
        }

        .lod-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 700;
            margin-left: 5px;
        }

        .lod-ultra { background: #27ae60; color: white; }
        .lod-high { background: #f39c12; color: white; }
        .lod-medium { background: #e74c3c; color: white; }
        .lod-fast { background: #9b59b6; color: white; }

        .heat-label {
            color: #e74c3c;
            font-size: 0.9em;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .heat-bar-container {
            width: 100%;
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .heat-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #3498db 0%, #00ff88 30%, #f39c12 60%, #e74c3c 100%);
            transition: width 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 0 10px rgba(231,76,60,0.5);
        }

        .heat-value {
            color: #fff;
            font-size: 0.85em;
            font-weight: 600;
            text-align: center;
        }

        /* Footer */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(10,14,39,0.9);
            padding: 10px 20px;
            text-align: center;
            font-size: 0.8em;
            color: #666;
            border-top: 1px solid rgba(0,255,136,0.2);
        }

        .footer a {
            color: #00ff88;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <!-- Compact Top Bar -->
    <div class="top-bar">
        <h1>üî¨ Reality Observer Simulator</h1>
        <a href="index.html">‚Üê Back to Theory</a>
    </div>

    <!-- Main Visualization -->
    <div class="main-canvas">
        <!-- System State & Calculations (left column) -->
        <div class="math-panel">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #00ff88;">
                <h2 style="margin: 0;">üìä System State</h2>
                <button id="infoModalBtn" style="background: rgba(0,255,136,0.2); border: 2px solid #00ff88; color: #00ff88; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 1em;">
                    ‚ÑπÔ∏è Learn All Formulas
                </button>
            </div>

                <!-- Live System Stats (simple rows) -->
                <div style="margin-bottom: 20px;">
                    <div class="metric">
                        <span class="metric-label">Population:</span>
                        <span class="metric-value" id="popDisplay">20</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Temperature:</span>
                        <span class="metric-value" id="tempDisplay">T = 0.000</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">FPS:</span>
                        <span class="metric-value perf-fps" id="fpsValue">60</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">LOD Mode:</span>
                        <span class="metric-value perf-lod" id="lodMode">ULTRA</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Effects:</span>
                        <span class="metric-value perf-effects" id="effectsActive">ALL</span>
                    </div>
                </div>

                <div style="height: 1px; background: rgba(0,255,136,0.2); margin: 20px 0;"></div>

            <div class="math-section">
                <div class="metric">
                    <span class="metric-label">
                        Particles (N):
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Population Size (N)</h4>
                                <p>The total number of entities in your system - could be particles, people, neurons, or concepts.</p>
                                <p class="why">Why it matters:</p>
                                <p>Larger N means more complexity, more interactions, and exponentially higher computational costs (N¬≤ scaling). In real systems, observers can't track everything!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="particleCount">0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">
                        Connections (E):
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Network Edges (E)</h4>
                                <p>Number of active relationships between particles within connection distance. Forms the network topology.</p>
                                <p class="why">Why it matters:</p>
                                <p>High E means highly interconnected system (social clusters, quantum entanglement). Low E means isolated particles. Network structure determines information flow!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="connectionCount">0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">
                        Observer Power:
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Computational Budget</h4>
                                <p>How much resolution your observer has. Low power = coarse-grained view (particles snap to grid). High power = fine-grained precision.</p>
                                <p class="why">Why it matters:</p>
                                <p>Real observers (humans, AI, instruments) have LIMITED compute! You can't measure everything perfectly. Trade-off between detail and cost.</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="observerPower">100%</span>
                </div>

                <div style="height: 1px; background: rgba(0,255,136,0.2); margin: 15px 0;"></div>

                <div class="metric">
                    <span class="metric-label">
                        Shannon Entropy (H):
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Shannon Entropy (Information Theory)</h4>
                                <p><strong>H = -Œ£ p(x) log‚ÇÇ p(x)</strong></p>
                                <p>Measures disorder/unpredictability. We divide space into grid cells and calculate probability distribution. Higher H = more spread out, more random.</p>
                                <p class="why">Why it matters:</p>
                                <p>2nd Law of Thermodynamics: entropy ALWAYS increases in closed systems! Watch it grow when you hit Play. Core to information theory, physics, and ML.</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="entropyValue">0.000 bits</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    H = -Œ£ p(x) log‚ÇÇ p(x) | From 2D spatial distribution
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Uncertainty (Œîx¬∑Œîp):
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Heisenberg Uncertainty Principle</h4>
                                <p><strong>Œîx ¬∑ Œîp ‚â• ‚Ñè/2</strong></p>
                                <p>Product of position variance (œÉ‚Çì) and velocity variance (œÉ‚Çö). You can't know both precisely at once!</p>
                                <p class="why">Why it matters:</p>
                                <p>Fundamental limit in quantum mechanics. Trade-off between knowing WHERE something is vs HOW FAST it's moving. Quantum observers see higher uncertainty than classical!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="uncertaintyValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    œÉ_pos √ó œÉ_vel | Position & velocity variance
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Network Density (œÅ):
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Graph Density</h4>
                                <p><strong>œÅ = 2E / N(N-1)</strong></p>
                                <p>Ratio of actual connections to maximum possible connections. œÅ=1 means fully connected (every particle connects to every other), œÅ=0 means totally isolated.</p>
                                <p class="why">Why it matters:</p>
                                <p>Determines information flow speed, system robustness, phase transitions. Social networks: high œÅ = echo chambers. Neural networks: connectivity = computational power!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="densityValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    2E / N(N-1) | Actual vs possible connections
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Computational Cost (C):
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Algorithmic Complexity</h4>
                                <p><strong>C = N¬≤</strong></p>
                                <p>Number of pairwise distance calculations per frame. Checking every particle against every other = O(N¬≤) scaling.</p>
                                <p class="why">Why it matters:</p>
                                <p>This is WHY coarse-graining exists! Real systems (brains, GPUs, nature) can't compute everything. Limits to observation = fundamental to reality. Watch C explode as N increases!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="complexityValue">0 ops</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    N¬≤ | Pairwise distance calculations per frame
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Free Energy (F):
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Helmholtz Free Energy</h4>
                                <p><strong>F = U - TS</strong></p>
                                <p>Combines potential energy (U) with entropy (S) and temperature (T). Lower F = more stable configuration.</p>
                                <p class="why">Why it matters:</p>
                                <p>Systems minimize free energy! Brains use "Free Energy Principle" (Karl Friston). Connects thermodynamics to prediction, consciousness, and life itself. Active inference = minimize surprise!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="freeEnergyValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    U - TS | Potential energy minus entropy term
                </p>

                <div style="height: 1px; background: rgba(0,255,136,0.2); margin: 15px 0;"></div>

                <div class="metric">
                    <span class="metric-label">
                        Temperature (T):
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Thermodynamic Temperature</h4>
                                <p><strong>T ‚àù ‚àö(‚ü®v¬≤‚ü©)</strong></p>
                                <p>Derived from kinetic energy. Higher T = faster particles = more thermal motion.</p>
                                <p class="why">Why it matters:</p>
                                <p>Temperature drives entropy growth! Hot systems are chaotic, cold systems can form structure. Controls phase transitions (solid‚Üíliquid‚Üígas). Heat = randomness!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="temperatureValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    ‚àö(‚ü®v¬≤‚ü©) | From kinetic energy/velocity variance
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Kinetic Energy (K):
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Kinetic Energy (Motion)</h4>
                                <p><strong>K = ¬Ωmv¬≤</strong></p>
                                <p>Energy of motion. Sum of all particle velocities squared.</p>
                                <p class="why">Why it matters:</p>
                                <p>Half of total energy (K+U). Can be converted to potential energy and back. Conservation of energy = fundamental law. Kinetic energy IS heat in statistical mechanics!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="kineticValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    ‚ü®¬Ωmv¬≤‚ü© | Average kinetic energy per particle
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Potential Energy (U):
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Potential Energy (Interactions)</h4>
                                <p>Energy stored in particle interactions. Lennard-Jones potential: attractive at medium range, repulsive up close.</p>
                                <p class="why">Why it matters:</p>
                                <p>Determines stable configurations! Low U = particles found their "happy distance". Molecular bonds, galaxies, social networks - all minimize potential energy.</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="potentialValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    Lennard-Jones | Particle interaction energy
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Spatial Spread (œÉ·µ£):
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Root Mean Square Spread</h4>
                                <p>Average distance from center of mass. Measures how "puffed out" the system is.</p>
                                <p class="why">Why it matters:</p>
                                <p>Grows with entropy! When you hit Play, watch particles diffuse outward. 2nd law in action. Star formation, gas clouds, crowd dispersion - all follow this!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="spatialSpreadValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    RMS distance from center of mass
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Info Deficit (ŒîH):
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Information Deficit</h4>
                                <p><strong>ŒîH = H_max - H</strong></p>
                                <p>How much entropy remains before reaching maximum disorder (uniform distribution).</p>
                                <p class="why">Why it matters:</p>
                                <p>Measures available "structure" or "order" in the system. High ŒîH = still organized. Low ŒîH = approaching heat death! Information = negative entropy (negentropy).</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="infoDeficitValue">0.000 bits</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    H_max - H | Distance from maximum entropy
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Avg Velocity (‚ü®v‚ü©):
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Mean Particle Speed</h4>
                                <p>Average velocity magnitude across all particles. Proxy for system momentum.</p>
                                <p class="why">Why it matters:</p>
                                <p>Related to temperature and kinetic energy. Fast particles = hot system. Shows how "active" the system is. Zero mean velocity = no net drift.</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="avgVelocityValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    Mean particle speed | System momentum
                </p>

                <div style="height: 1px; background: rgba(0,255,136,0.2); margin: 15px 0;"></div>

                <div class="metric">
                    <span class="metric-label">
                        Total Energy (E_total):
                        <span style="display:none;" class="tooltip-icon-removed">
                            <span class="tooltip-content-removed">
                                <h4>Total System Energy</h4>
                                <p><strong>E_total = K + U</strong></p>
                                <p>Sum of kinetic energy (motion) and potential energy (interactions).</p>
                                <p class="why">Why it matters:</p>
                                <p><strong>First Law of Thermodynamics:</strong> In isolated systems, energy is conserved. Here, there's slight damping (0.99x per frame) that dissipates energy to simulate environmental friction. Energy flows between K‚ÜîU, but total slowly decreases. In perfect isolation, it would be constant!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="totalEnergyValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    K + U | Conserved in closed systems
                </p>
            </div>
        </div>

        <!-- Observer Card (full width row above everything) -->
        <div class="observer-info-card" id="observerCard">
            <div style="display: flex; gap: 30px; align-items: center;">
                <!-- Observer Info (left side) -->
                <div style="flex: 1; text-align: left;">
                    <div class="observer-name" id="observerTitle">üåÄ Quantum Observer</div>
                    <div class="observer-desc-inline" id="observerDesc">Superpositions, Multiple States, Probabilistic Reality</div>
                    <div class="observer-description" id="observerDescription">
                        Sees particles in MULTIPLE states at once. Reality is probabilistic - particles exist as "waves" until measured. Ghost particles show superposition states.
                    </div>
                </div>

                <!-- Play Button (right side) -->
                <div style="text-align: center;">
                    <button id="playBtn" onclick="toggleTimeEvolution()" style="padding: 15px 40px; background: #00ff88; color: #0a0e27; border: none; border-radius: 8px; font-weight: 700; cursor: pointer; font-size: 1.2em; box-shadow: 0 4px 15px rgba(0,255,136,0.4); margin-bottom: 8px; display: block;">
                        <span id="playIcon">‚ñ∂Ô∏è</span> <span id="playText">Play</span>
                    </button>
                    <div style="color: #aaa; font-size: 1em; line-height: 1.5;">
                        See entropy increase,<br>particles spread!
                    </div>
                </div>
            </div>
        </div>

        <!-- Canvas (center) -->
        <div class="viz-container">
            <canvas id="reality-canvas"></canvas>
        </div>

        <!-- Controls (right column) -->
        <div class="controls-panel">
            <div class="cascade-indicator" id="cascadeIndicator">‚ö° Cascade Update</div>
            <h2>Controls</h2>

                <!-- CONTROLS -->
                <div class="control-section">
                <h3>Observer Type</h3>
                <div class="observer-select">
                    <button class="active" data-observer="quantum" onclick="switchObserver('quantum')">üî¨ Quantum</button>
                    <button data-observer="classical" onclick="switchObserver('classical')">üéØ Classical</button>
                    <button data-observer="social" onclick="switchObserver('social')">üåê Social</button>
                    <button data-observer="conscious" onclick="switchObserver('conscious')">üß† Conscious</button>
                    <button data-observer="ai" onclick="switchObserver('ai')">ü§ñ AI</button>
                </div>

                <div class="control-row">
                    <label>Population Size (N) - LOD Optimized ‚ö°</label>
                    <input type="range" id="populationSlider" min="20" max="1000" value="20" step="20" oninput="updatePopulation(this.value)">
                    <div class="control-values">
                        <span>20</span>
                        <span id="populationValue">20</span>
                        <span style="color: #00ff88; font-weight: 700;">1k</span>
                    </div>
                    <p style="color: #888; font-size: 0.95em; margin-top: 8px; line-height: 1.5;">
                        üöÄ GPU-accelerated! Scale up to see emergent patterns at massive scale!
                    </p>
                </div>

                <div class="control-row">
                    <label>Observer Power (Coarse-graining)</label>
                    <input type="range" id="budgetSlider" min="0" max="100" value="100" oninput="updateBudget(this.value)">
                    <div class="control-values">
                        <span>Coarse</span>
                        <span id="budgetValue">100%</span>
                        <span>Fine</span>
                    </div>
                </div>

                <div class="control-row">
                    <label>Evolution Speed</label>
                    <input type="range" id="speedSlider" min="1" max="10" value="5" oninput="updateSpeed(this.value)" style="width: 100%;">
                    <div class="control-values">
                        <span>Slow</span>
                        <span id="speedValue">5x</span>
                        <span>Fast</span>
                    </div>
                    <p style="color: #888; font-size: 0.95em; margin-top: 8px; line-height: 1.5;">
                        How fast particles spread and entropy increases
                    </p>
                </div>

                <div class="control-row">
                    <label>Heat Control (Add/Remove Energy)</label>
                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                        <button onclick="addHeat()" style="flex: 1; padding: 12px; background: #e74c3c; color: white; border: none; border-radius: 6px; font-weight: 700; cursor: pointer; font-size: 1em;">
                            üî• Add Heat
                        </button>
                        <button onclick="removeHeat()" style="flex: 1; padding: 12px; background: #3498db; color: white; border: none; border-radius: 6px; font-weight: 700; cursor: pointer; font-size: 1em;">
                            ‚ùÑÔ∏è Cool Down
                        </button>
                    </div>
                    <p style="color: #888; font-size: 0.95em; margin-top: 8px; line-height: 1.5;">
                        Heat = kinetic energy. Watch Temperature, K, and Entropy increase with heat!
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Comprehensive Info Modal -->
    <div id="infoModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(10,14,39,0.98); border: 4px solid #00ff88; border-radius: 16px; padding: 40px; width: 800px; max-width: 95vw; max-height: 90vh; overflow-y: auto; z-index: 10000; box-shadow: 0 12px 60px rgba(0,255,136,1), 0 0 0 9999px rgba(0,0,0,0.85);">
        <h2 style="color: #00ff88; font-size: 2.2em; text-align: center; margin: 0 0 30px 0; border-bottom: 3px solid #00ff88; padding-bottom: 20px;">üìö Physics & Math Reference Guide</h2>

        <div style="columns: 2; column-gap: 40px;">
            <!-- Each metric explained -->
            <div style="break-inside: avoid; margin-bottom: 30px;">
                <h3 style="color: #00ff88; font-size: 1.5em; margin-bottom: 12px;">Shannon Entropy (H)</h3>
                <p style="color: #f39c12; font-size: 1.2em; font-weight: 700; margin: 10px 0;">H = -Œ£ p(x) log‚ÇÇ p(x)</p>
                <p style="color: #eee; font-size: 1.1em; line-height: 1.6;">Measures disorder/unpredictability. Higher H = more spread out, more random.</p>
                <p style="color: #aaa; font-size: 1em; line-height: 1.5; margin-top: 10px;"><strong>Why:</strong> 2nd Law of Thermodynamics - entropy ALWAYS increases!</p>
            </div>

            <div style="break-inside: avoid; margin-bottom: 30px;">
                <h3 style="color: #00ff88; font-size: 1.5em; margin-bottom: 12px;">Heisenberg Uncertainty</h3>
                <p style="color: #f39c12; font-size: 1.2em; font-weight: 700; margin: 10px 0;">Œîx ¬∑ Œîp ‚â• ‚Ñè/2</p>
                <p style="color: #eee; font-size: 1.1em; line-height: 1.6;">You can't know both position and velocity precisely at once!</p>
                <p style="color: #aaa; font-size: 1em; line-height: 1.5; margin-top: 10px;"><strong>Why:</strong> Fundamental quantum limit. Trade-off between WHERE vs HOW FAST.</p>
            </div>

            <div style="break-inside: avoid; margin-bottom: 30px;">
                <h3 style="color: #00ff88; font-size: 1.5em; margin-bottom: 12px;">Network Density (œÅ)</h3>
                <p style="color: #f39c12; font-size: 1.2em; font-weight: 700; margin: 10px 0;">œÅ = 2E / N(N-1)</p>
                <p style="color: #eee; font-size: 1.1em; line-height: 1.6;">Ratio of actual connections to maximum possible. œÅ=1 = fully connected.</p>
                <p style="color: #aaa; font-size: 1em; line-height: 1.5; margin-top: 10px;"><strong>Why:</strong> Shows how interconnected the system is.</p>
            </div>

            <div style="break-inside: avoid; margin-bottom: 30px;">
                <h3 style="color: #00ff88; font-size: 1.5em; margin-bottom: 12px;">Free Energy (F)</h3>
                <p style="color: #f39c12; font-size: 1.2em; font-weight: 700; margin: 10px 0;">F = U - TS</p>
                <p style="color: #eee; font-size: 1.1em; line-height: 1.6;">Combines potential energy with entropy and temperature. Lower F = more stable.</p>
                <p style="color: #aaa; font-size: 1em; line-height: 1.5; margin-top: 10px;"><strong>Why:</strong> Systems minimize free energy! Core to consciousness and active inference.</p>
            </div>

            <div style="break-inside: avoid; margin-bottom: 30px;">
                <h3 style="color: #00ff88; font-size: 1.5em; margin-bottom: 12px;">Kinetic Energy (K)</h3>
                <p style="color: #f39c12; font-size: 1.2em; font-weight: 700; margin: 10px 0;">K = ¬Ωmv¬≤</p>
                <p style="color: #eee; font-size: 1.1em; line-height: 1.6;">Energy of motion. Sum of all particle velocities squared.</p>
                <p style="color: #aaa; font-size: 1em; line-height: 1.5; margin-top: 10px;"><strong>Why:</strong> Kinetic energy IS heat in statistical mechanics!</p>
            </div>

            <div style="break-inside: avoid; margin-bottom: 30px;">
                <h3 style="color: #00ff88; font-size: 1.5em; margin-bottom: 12px;">Total Energy (E)</h3>
                <p style="color: #f39c12; font-size: 1.2em; font-weight: 700; margin: 10px 0;">E = K + U</p>
                <p style="color: #eee; font-size: 1.1em; line-height: 1.6;">Sum of kinetic and potential energy.</p>
                <p style="color: #aaa; font-size: 1em; line-height: 1.5; margin-top: 10px;"><strong>Why:</strong> In isolated systems, energy is conserved (1st Law). Here there's slight damping.</p>
            </div>

            <div style="break-inside: avoid; margin-bottom: 30px;">
                <h3 style="color: #00ff88; font-size: 1.5em; margin-bottom: 12px;">Temperature (T)</h3>
                <p style="color: #f39c12; font-size: 1.2em; font-weight: 700; margin: 10px 0;">T ‚àù ‚àö(‚ü®v¬≤‚ü©)</p>
                <p style="color: #eee; font-size: 1.1em; line-height: 1.6;">Proportional to RMS velocity. Measures average kinetic energy of particles.</p>
                <p style="color: #aaa; font-size: 1em; line-height: 1.5; margin-top: 10px;"><strong>Why:</strong> Temperature IS particle motion! Hot = fast, cold = slow.</p>
            </div>

            <div style="break-inside: avoid; margin-bottom: 30px;">
                <h3 style="color: #00ff88; font-size: 1.5em; margin-bottom: 12px;">Potential Energy (U)</h3>
                <p style="color: #f39c12; font-size: 1.2em; font-weight: 700; margin: 10px 0;">Lennard-Jones Potential</p>
                <p style="color: #eee; font-size: 1.1em; line-height: 1.6;">Energy stored in particle interactions. Attractive at medium range, repulsive up close.</p>
                <p style="color: #aaa; font-size: 1em; line-height: 1.5; margin-top: 10px;"><strong>Why:</strong> Determines stable configurations - molecular bonds, galaxies, networks!</p>
            </div>

            <div style="break-inside: avoid; margin-bottom: 30px;">
                <h3 style="color: #00ff88; font-size: 1.5em; margin-bottom: 12px;">Spatial Spread (œÉ·µ£)</h3>
                <p style="color: #f39c12; font-size: 1.2em; font-weight: 700; margin: 10px 0;">RMS distance from center</p>
                <p style="color: #eee; font-size: 1.1em; line-height: 1.6;">Measures how "puffed out" the system is. Increases as particles diffuse.</p>
                <p style="color: #aaa; font-size: 1em; line-height: 1.5; margin-top: 10px;"><strong>Why:</strong> Directly related to entropy - spreading = disorder!</p>
            </div>

            <div style="break-inside: avoid; margin-bottom: 30px;">
                <h3 style="color: #00ff88; font-size: 1.5em; margin-bottom: 12px;">Computational Cost (C)</h3>
                <p style="color: #f39c12; font-size: 1.2em; font-weight: 700; margin: 10px 0;">C = N¬≤</p>
                <p style="color: #eee; font-size: 1.1em; line-height: 1.6;">Number of pairwise calculations per frame. O(N¬≤) scaling.</p>
                <p style="color: #aaa; font-size: 1em; line-height: 1.5; margin-top: 10px;"><strong>Why:</strong> Shows why observers can't track everything - compute explodes!</p>
            </div>

            <div style="break-inside: avoid; margin-bottom: 30px;">
                <h3 style="color: #00ff88; font-size: 1.5em; margin-bottom: 12px;">Info Deficit (ŒîH)</h3>
                <p style="color: #f39c12; font-size: 1.2em; font-weight: 700; margin: 10px 0;">ŒîH = H_max - H</p>
                <p style="color: #eee; font-size: 1.1em; line-height: 1.6;">How much entropy remains before reaching maximum disorder (uniform distribution).</p>
                <p style="color: #aaa; font-size: 1em; line-height: 1.5; margin-top: 10px;"><strong>Why:</strong> Shows how far from equilibrium you are!</p>
            </div>
        </div>

        <div style="text-align: center; margin-top: 30px;">
            <button onclick="document.getElementById('infoModal').style.display='none'" style="background: #00ff88; color: #0a0e27; border: none; padding: 12px 32px; border-radius: 8px; font-size: 1.2em; font-weight: 700; cursor: pointer;">
                Got it! ‚úì
            </button>
        </div>
    </div>

    <!-- Footer -->
    <div class="footer">
        ¬© 2025 Jacob Edwards | <a href="index.html">‚Üê Back to Theory</a> | <a href="https://github.com/ElementalInsights/observer-reality-explorer" target="_blank">GitHub</a>
    </div>

    <script>
        // ===== STATE =====
        let currentObserver = 'quantum';
        let computationalBudget = 100;
        let timeEvolutionActive = false;
        let evolutionSpeed = 5;
        let evolutionTime = 0;
        let populationSize = 20;
        let animationFrameId = null;

        const observerConfigs = {
            quantum: {
                name: 'üåÄ Quantum Observer',
                color: '#9b59b6',
                description: 'Sees particles in MULTIPLE states at once (superposition). Reality is probabilistic - particles exist as "waves" of possibility until measured. Ghost particles show "HERE or THERE" states before observation collapses the wave function.',
                emphasis: 'Superpositions, Multiple States, Probabilistic Reality, Wave Function Collapse',
                particleSize: 3,
                connectionDistance: 100,
                showUncertainty: true,
                showSuperposition: true
            },
            classical: {
                name: 'üéØ Classical Observer',
                color: '#3498db',
                description: 'Sees particles with EXACT positions and velocities. Reality is deterministic - if you know the initial conditions, you can predict the future perfectly. Trajectory trails show precise paths through spacetime. Newtonian mechanics.',
                emphasis: 'Determinism, Single Definite States, Predictable Trajectories, Perfect Certainty',
                particleSize: 5,
                connectionDistance: 150,
                showUncertainty: false,
                showSuperposition: false
            },
            social: {
                name: 'üåê Social Observer',
                color: '#27ae60',
                description: 'Sees CLUSTERS and group membership. Reality is relational - entities are defined by their tribal affiliations. Connections only form within groups (echo chambers!). Different colors = different social identities. Us vs Them.',
                emphasis: 'Groups, Tribes, In-groups vs Out-groups, Echo Chambers, Identity',
                particleSize: 7,
                connectionDistance: 120,
                showClusters: true,
                clusterCount: 5
            },
            conscious: {
                name: 'üß† Conscious Observer',
                color: '#e67e22',
                description: 'Sees PREDICTION ERRORS and surprises. Reality is about minimizing free energy (surprise). Red particles = high prediction error (unexpected!). Consciousness emerges from integrating information to predict and control. Active inference.',
                emphasis: 'Prediction Errors, Free Energy Minimization, Integrated Information, Active Inference',
                particleSize: 4,
                connectionDistance: 110,
                showFlows: true
            },
            ai: {
                name: 'ü§ñ AI Observer',
                color: '#1abc9c',
                description: 'Sees SEMANTIC RELATIONSHIPS in high-dimensional embedding space. Reality is vectors - closer particles = more similar meaning. Connection thickness shows semantic similarity. Like word2vec, transformers, or neural network attention.',
                emphasis: 'Embeddings, Semantic Distance, Vector Space, Attention Weights',
                particleSize: 3,
                connectionDistance: 90,
                showVectors: true
            }
        };

        // ===== OBSERVER SWITCHING =====
        function switchObserver(observerType) {
            const previousObserver = currentObserver;
            currentObserver = observerType;
            const config = observerConfigs[observerType];

            // Update button states
            document.querySelectorAll('.observer-select button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update info display
            const infoDisplay = document.getElementById('infoDisplay');
            // Update observer info display
            document.getElementById('observerTitle').textContent = config.name;
            document.getElementById('observerDesc').textContent = config.emphasis;
            document.getElementById('observerDescription').textContent = config.description;

            // === WAVE FUNCTION COLLAPSE! ===
            if (previousObserver === 'quantum' && observerType !== 'quantum') {
                // Switching FROM quantum to anything else = MEASUREMENT
                // Superpositions collapse into definite states
                collapseWaveFunction(() => {
                    // Update visualization without regenerating particles
                    updateObserverVisualization();
                    setTimeout(() => updateMathPanel(true), 500);
                });
            } else if (window.currentParticles && window.currentParticles.length === populationSize) {
                // Particles exist, just update visualization
                updateObserverVisualization();
                setTimeout(() => updateMathPanel(true), 500);
            } else {
                // First load or population changed - create new particles
                createReality();
                setTimeout(() => updateMathPanel(true), 500);
            }
        }

        // Wave function collapse animation
        function collapseWaveFunction(callback) {
            const ghosts = d3.selectAll('.ghosts circle');
            const particles = d3.selectAll('.particles circle');

            // Show collapse notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(155, 89, 182, 0.95);
                color: white;
                padding: 30px 50px;
                border-radius: 15px;
                font-size: 1.5em;
                font-weight: 700;
                z-index: 10000;
                box-shadow: 0 0 50px rgba(155, 89, 182, 0.8);
                animation: pulse 0.5s ease-out;
            `;
            notification.innerHTML = '‚ö° WAVE FUNCTION COLLAPSE ‚ö°<br><span style="font-size: 0.6em;">Superpositions ‚Üí Definite State</span>';
            document.body.appendChild(notification);

            // Animate ghosts collapsing into particles
            ghosts.transition()
                .duration(800)
                .attr('r', 0)
                .attr('opacity', 0);

            // Pulse particles
            particles.transition()
                .duration(300)
                .attr('r', d => observerConfigs[currentObserver].particleSize * 2)
                .transition()
                .duration(300)
                .attr('r', d => observerConfigs[currentObserver].particleSize);

            setTimeout(() => {
                notification.remove();
                callback();
            }, 1000);
        }

        // ===== COMPUTATIONAL BUDGET =====
        function updateBudget(value) {
            computationalBudget = parseInt(value);
            document.getElementById('budgetValue').textContent = value + '%';
            document.getElementById('observerPower').textContent = value + '%';

            // Coarse-graining now handled in Canvas rendering (no D3 needed!)
            // The animation loop will apply quantization based on computationalBudget

            // Update math panel with CASCADE effect
            updateMathPanel(true);
        }

        // ===== UPDATE MATH PANEL =====
        function updateMathPanel(showCascade = false) {
            const config = observerConfigs[currentObserver];
            const particles = window.currentParticles || [];
            const connections = window.currentConnections || [];

            // Show cascade indicator if requested
            if (showCascade) {
                const indicator = document.getElementById('cascadeIndicator');
                indicator.classList.add('active');
                setTimeout(() => indicator.classList.remove('active'), 1500);

                // Animate each math section
                document.querySelectorAll('.math-section').forEach((section, i) => {
                    setTimeout(() => {
                        section.classList.add('cascade-active');
                        setTimeout(() => section.classList.remove('cascade-active'), 600);
                    }, i * 100);
                });
            }

            // Particle count
            document.getElementById('particleCount').textContent = particles.length;

            // Connection count
            document.getElementById('connectionCount').textContent = connections.length;

            // Shannon Entropy - REAL calculation from 2D spatial distribution
            let entropy = 0;
            if (particles.length > 0) {
                // Create 2D grid based on observer power (coarse-graining)
                const gridResolution = Math.max(5, Math.floor(20 * (computationalBudget / 100)));
                const width = 1000;
                const height = 600;
                const cellWidth = width / gridResolution;
                const cellHeight = height / gridResolution;

                // Count particles in each cell
                const grid = new Array(gridResolution * gridResolution).fill(0);

                particles.forEach(p => {
                    const cellX = Math.min(Math.floor(p.x / cellWidth), gridResolution - 1);
                    const cellY = Math.min(Math.floor(p.y / cellHeight), gridResolution - 1);
                    const cellIndex = cellY * gridResolution + cellX;
                    grid[cellIndex]++;
                });

                // Calculate Shannon entropy from probability distribution
                const totalParticles = particles.length;
                grid.forEach(count => {
                    if (count > 0) {
                        const probability = count / totalParticles;
                        entropy -= probability * Math.log2(probability);
                    }
                });

                // Max entropy for uniform distribution
                const maxEntropy = Math.log2(gridResolution * gridResolution);

                // At low power, we lose information (higher entropy relative to our grid)
                const observerUncertainty = (100 - computationalBudget) / 100;
                entropy = entropy + (maxEntropy - entropy) * observerUncertainty;
            }

            document.getElementById('entropyValue').textContent = `H = ${entropy.toFixed(3)} bits`;

            // Heisenberg Uncertainty - REAL calculation from position/velocity variance
            let posVariance = 0;
            let velVariance = 0;

            if (particles.length > 1) {
                // Calculate mean position and velocity
                const meanX = particles.reduce((sum, p) => sum + p.x, 0) / particles.length;
                const meanY = particles.reduce((sum, p) => sum + p.y, 0) / particles.length;
                const meanVx = particles.reduce((sum, p) => sum + p.vx, 0) / particles.length;
                const meanVy = particles.reduce((sum, p) => sum + p.vy, 0) / particles.length;

                // Calculate variance (Œîx)¬≤ and (Œîp)¬≤
                posVariance = particles.reduce((sum, p) => {
                    const dx = p.x - meanX;
                    const dy = p.y - meanY;
                    return sum + (dx * dx + dy * dy);
                }, 0) / particles.length;

                velVariance = particles.reduce((sum, p) => {
                    const dvx = p.vx - meanVx;
                    const dvy = p.vy - meanVy;
                    return sum + (dvx * dvx + dvy * dvy);
                }, 0) / particles.length;

                // At low observer power, we can't measure as precisely (increased uncertainty)
                const measurementError = 1 + (100 - computationalBudget) / 50;
                posVariance *= measurementError;
                velVariance *= measurementError;
            }

            // Œîx ¬∑ Œîp (standard deviations multiplied)
            const uncertainty = Math.sqrt(posVariance) * Math.sqrt(velVariance);

            // Quantum vs classical difference
            const quantumFactor = currentObserver === 'quantum' ? 1.5 : 1.0;

            document.getElementById('uncertaintyValue').textContent = `Œîx¬∑Œîp = ${(uncertainty * quantumFactor).toFixed(3)}`;

            // Network Density
            const maxConnections = particles.length * (particles.length - 1) / 2;
            const density = maxConnections > 0 ? connections.length / maxConnections : 0;
            document.getElementById('densityValue').textContent = `œÅ = ${density.toFixed(3)}`;

            // Computational Cost
            const complexity = particles.length * particles.length;
            document.getElementById('complexityValue').textContent = `C = ${complexity.toLocaleString()} ops`;

            // Free Energy - REAL calculation based on system configuration
            // F = U - TS where U = potential energy, T = "temperature", S = entropy

            // Calculate potential energy from particle interactions
            let potentialEnergy = 0;
            // config already declared at top of function

            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Lennard-Jones-like potential: attractive at medium range, repulsive at close range
                    if (dist < config.connectionDistance) {
                        // Attractive term
                        potentialEnergy -= 1.0 / (dist + 1);
                    }
                    if (dist < 20) {
                        // Repulsive term at very close distances
                        potentialEnergy += 10.0 / (dist + 1);
                    }
                }
            }

            // Normalize by particle count
            potentialEnergy /= Math.max(1, particles.length);

            // Temperature proxy from kinetic energy (velocity variance)
            const kineticEnergy = particles.reduce((sum, p) => {
                return sum + (p.vx * p.vx + p.vy * p.vy);
            }, 0) / Math.max(1, particles.length);

            const temperature = Math.sqrt(kineticEnergy) * 0.1;

            // Free Energy: F = U - TS
            // Lower free energy = more stable, ordered system
            const freeEnergy = potentialEnergy - temperature * entropy * 0.01;

            document.getElementById('freeEnergyValue').textContent = `F = ${freeEnergy.toFixed(3)}`;

            // ===== NEW METRICS =====

            // Temperature (already calculated above)
            document.getElementById('temperatureValue').textContent = `T = ${temperature.toFixed(3)}`;

            // Update visual heat monitor
            const maxTemp = 2.0; // Reasonable max temperature for the bar
            const tempPercent = Math.min((temperature / maxTemp) * 100, 100);
            const heatBar = document.getElementById('heatBar');
            const heatValue = document.getElementById('heatValue');
            if (heatBar) {
                heatBar.style.width = tempPercent + '%';
                // Change glow intensity based on temperature
                heatBar.style.boxShadow = `0 0 ${10 + tempPercent * 0.3}px rgba(231,76,60,${0.3 + tempPercent * 0.007})`;
            }
            if (heatValue) {
                heatValue.textContent = `T = ${temperature.toFixed(3)}`;

                // Update unified monitor temp
                document.getElementById('tempDisplay').textContent = `T = ${temperature.toFixed(3)}`;
            }

            // Kinetic Energy (already calculated above)
            document.getElementById('kineticValue').textContent = `K = ${kineticEnergy.toFixed(3)}`;

            // Potential Energy (already calculated above)
            document.getElementById('potentialValue').textContent = `U = ${potentialEnergy.toFixed(3)}`;

            // Spatial Spread - RMS distance from center of mass
            let spatialSpread = 0;
            if (particles.length > 0) {
                // Calculate center of mass
                const centerX = particles.reduce((sum, p) => sum + p.x, 0) / particles.length;
                const centerY = particles.reduce((sum, p) => sum + p.y, 0) / particles.length;

                // Calculate RMS distance from center
                const sumSquaredDist = particles.reduce((sum, p) => {
                    const dx = p.x - centerX;
                    const dy = p.y - centerY;
                    return sum + (dx * dx + dy * dy);
                }, 0);

                spatialSpread = Math.sqrt(sumSquaredDist / particles.length);
            }
            document.getElementById('spatialSpreadValue').textContent = `œÉ·µ£ = ${spatialSpread.toFixed(3)}`;

            // Information Deficit - H_max - H (how far from maximum entropy)
            const gridResolution = Math.max(5, Math.floor(20 * (computationalBudget / 100)));
            const maxEntropy = Math.log2(gridResolution * gridResolution);
            const infoDeficit = maxEntropy - entropy;
            document.getElementById('infoDeficitValue').textContent = `ŒîH = ${infoDeficit.toFixed(3)} bits`;

            // Average Velocity - mean speed
            let avgVelocity = 0;
            if (particles.length > 0) {
                const totalSpeed = particles.reduce((sum, p) => {
                    const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                    return sum + speed;
                }, 0);
                avgVelocity = totalSpeed / particles.length;
            }
            document.getElementById('avgVelocityValue').textContent = `‚ü®v‚ü© = ${avgVelocity.toFixed(3)}`;

            // Total Energy = Kinetic + Potential (should be conserved!)
            const totalEnergy = (kineticEnergy * particles.length) + (potentialEnergy * particles.length);
            document.getElementById('totalEnergyValue').textContent = `E = ${totalEnergy.toFixed(3)}`;
        }

        // ===== UPDATE OBSERVER VISUALIZATION (keep particles, change view) =====
        function updateObserverVisualization() {
            const config = observerConfigs[currentObserver];
            const particles = window.currentParticles || [];

            if (particles.length === 0 || particles.length !== populationSize) {
                createReality();
                return;
            }

            // Update cluster assignments if switching to/from social
            if (currentObserver === 'social' && config.clusterCount) {
                const clusterColors = [
                    '#ff4757',  // BRIGHT RED tribe
                    '#3498db',  // BRIGHT BLUE tribe
                    '#2ecc71',  // BRIGHT GREEN tribe
                    '#ffa502',  // BRIGHT ORANGE tribe
                    '#9b59b6'   // BRIGHT PURPLE tribe
                ];
                particles.forEach(p => {
                    if (p.cluster === undefined) {
                        p.cluster = Math.floor(Math.random() * config.clusterCount);
                    }
                    // ASSIGN COLORS!
                    p.color = clusterColors[p.cluster % clusterColors.length];
                });
            }

            // Cancel old animation and restart with new observer
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            // Restart animation with new observer config
            startAnimation();
        }

        // ===== CANVAS SETUP =====
        let canvas, ctx, width, height;

        function initCanvas() {
            if (!canvas) {
                canvas = document.getElementById('reality-canvas');
                ctx = canvas.getContext('2d', { alpha: false }); // Opaque for better performance
            }

            // Set canvas size (can be called on resize)
            const container = canvas.parentElement;
            width = container.clientWidth;
            height = container.clientHeight;

            // Set canvas resolution to match display size
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            // Scale context to match device pixel ratio
            ctx.scale(dpr, dpr);

            // Store dimensions
            window.canvasWidth = width;
            window.canvasHeight = height;
        }

        // ===== REALITY VISUALIZATION =====
        function createReality() {
            const config = observerConfigs[currentObserver];

            // Initialize canvas if not done
            if (!canvas) {
                initCanvas();
            }

            // Create NEW particles based on population slider
            const particles = Array.from({length: populationSize}, (_, i) => ({
                id: i,
                x: Math.random() * width,
                y: Math.random() * height,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                cluster: observerConfigs[currentObserver].clusterCount ? Math.floor(Math.random() * observerConfigs[currentObserver].clusterCount) : 0,
                trail: [] // For classical observer trails
            }));

            // Store globally
            window.currentParticles = particles;

            // Start animation loop
            startAnimation();
        }

        // ===== CANVAS ANIMATION LOOP (GIGA SCALE OPTIMIZED!) =====
        function startAnimation() {
            const particles = window.currentParticles;
            if (!particles || particles.length === 0) return;

            const config = observerConfigs[currentObserver];
            const N = particles.length;

            // === LOD (LEVEL OF DETAIL) SYSTEM ===
            // Adaptive quality based on particle count for GIGA SCALE performance!
            const lod = {
                // Visual quality settings
                useGlow: N < 5000,              // Shadows/glow only under 5k
                useGhosts: N < 10000,           // Quantum ghosts only under 10k
                useTrails: N < 5000,            // Classical trails only under 5k
                particleSize: N < 10000 ? config.particleSize : Math.max(1, config.particleSize * 0.6),

                // Update frequencies (higher N = less frequent updates)
                connectionUpdateInterval: N < 5000 ? 1 : N < 20000 ? 3 : 5,
                mathPanelUpdateInterval: N < 10000 ? 30 : 60,

                // Drawing optimizations
                maxConnectionsDrawn: Math.min(2000, Math.floor(100000 / N) * 10),
                batchDrawConnections: N > 10000  // Batch connections for speed
            };

            // Setup quantum ghosts (LOD aware)
            if (currentObserver === 'quantum' && lod.useGhosts) {
                const ghosts = [];
                particles.forEach(p => {
                    for (let i = 0; i < 2; i++) {
                        const angle = (i / 2) * Math.PI * 2;
                        const radius = 20 + Math.random() * 15;
                        ghosts.push({
                            x: p.x + Math.cos(angle) * radius,
                            y: p.y + Math.sin(angle) * radius,
                            parent: p.id,
                            angle: angle,
                            radius: radius
                        });
                    }
                });
                window.ghostParticles = ghosts;
            }

            // Setup classical trails (LOD aware)
            if (currentObserver === 'classical' && lod.useTrails) {
                particles.forEach(p => {
                    if (!p.trail) p.trail = [{x: p.x, y: p.y}];
                });
            }

            // Setup social cluster colors - VIBRANT DISTINCT tribes!
            if (currentObserver === 'social') {
                const clusterColors = [
                    '#ff4757',  // BRIGHT RED tribe
                    '#3498db',  // BRIGHT BLUE tribe
                    '#2ecc71',  // BRIGHT GREEN tribe
                    '#ffa502',  // BRIGHT ORANGE tribe
                    '#9b59b6'   // BRIGHT PURPLE tribe
                ];
                particles.forEach(p => {
                    p.color = clusterColors[p.cluster % clusterColors.length];
                });
            }

            // Cancel old animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            let frameCount = 0;
            let cachedConnections = null; // Cache connections!

            // FPS tracking
            let lastFrameTime = performance.now();
            let frameTimes = [];

            // Update LOD status display
            const lodModeEl = document.getElementById('lodMode');
            const effectsActiveEl = document.getElementById('effectsActive');

            if (N < 5000) {
                lodModeEl.textContent = 'ULTRA';
                effectsActiveEl.textContent = 'ALL';
            } else if (N < 10000) {
                lodModeEl.textContent = 'HIGH';
                effectsActiveEl.textContent = 'NO GLOW';
            } else if (N < 20000) {
                lodModeEl.textContent = 'MEDIUM';
                effectsActiveEl.textContent = 'MINIMAL';
            } else {
                lodModeEl.textContent = 'FAST';
                effectsActiveEl.textContent = 'BATCH';
            }

            function animate() {
                // FPS calculation
                const now = performance.now();
                const delta = now - lastFrameTime;
                lastFrameTime = now;

                frameTimes.push(delta);
                if (frameTimes.length > 30) frameTimes.shift();

                if (frameCount % 10 === 0) {
                    const avgDelta = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
                    const fps = Math.round(1000 / avgDelta);
                    document.getElementById('fpsValue').textContent = fps;
                }
                // === THERMODYNAMIC EVOLUTION ===
                if (timeEvolutionActive) {
                    evolutionTime += evolutionSpeed * 0.01;

                    // Build spatial grid for O(N) force calculations
                    const forceRange = config.connectionDistance * 0.5;
                    const forceCellSize = forceRange;
                    const forceGrid = {};

                    particles.forEach(p => {
                        const cellX = Math.floor(p.x / forceCellSize);
                        const cellY = Math.floor(p.y / forceCellSize);
                        const cellKey = `${cellX},${cellY}`;
                        if (!forceGrid[cellKey]) forceGrid[cellKey] = [];
                        forceGrid[cellKey].push(p);
                    });

                    // Apply repulsive forces (entropy increase!)
                    particles.forEach(p => {
                        let fx = 0, fy = 0;
                        const cellX = Math.floor(p.x / forceCellSize);
                        const cellY = Math.floor(p.y / forceCellSize);

                        // Check 3x3 neighborhood only
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                const neighborKey = `${cellX + dx},${cellY + dy}`;
                                const neighbors = forceGrid[neighborKey] || [];

                                neighbors.forEach(other => {
                                    if (p.id !== other.id) {
                                        const deltaX = p.x - other.x;
                                        const deltaY = p.y - other.y;
                                        const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                                        if (dist < forceRange && dist > 0) {
                                            const force = 0.01 * evolutionSpeed / (dist + 1);
                                            fx += (deltaX / dist) * force;
                                            fy += (deltaY / dist) * force;
                                        }
                                    }
                                });
                            }
                        }

                        // Thermal noise
                        const thermalNoise = 0.02 * evolutionSpeed;
                        fx += (Math.random() - 0.5) * thermalNoise;
                        fy += (Math.random() - 0.5) * thermalNoise;

                        p.vx += fx;
                        p.vy += fy;

                        // Light damping (simulates energy dissipation to environment)
                        // NOTE: This means energy is NOT perfectly conserved!
                        p.vx *= 0.99;
                        p.vy *= 0.99;

                        // Cap velocity
                        const maxVel = 3;
                        const vel = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                        if (vel > maxVel) {
                            p.vx = (p.vx / vel) * maxVel;
                            p.vy = (p.vy / vel) * maxVel;
                        }
                    });
                }

                // === UPDATE POSITIONS ===
                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;

                    // Bounce
                    if (p.x < 0 || p.x > width) p.vx *= -1;
                    if (p.y < 0 || p.y > height) p.vy *= -1;

                    // Keep in bounds
                    p.x = Math.max(0, Math.min(width, p.x));
                    p.y = Math.max(0, Math.min(height, p.y));
                });

                // === CLEAR CANVAS ===
                ctx.fillStyle = '#0a0e27';
                ctx.fillRect(0, 0, width, height);

                // === DRAW CONNECTIONS (Cached for performance!) ===
                // Only recalculate connections every N frames (HUGE perf boost at giga scale!)
                if (!cachedConnections || frameCount % lod.connectionUpdateInterval === 0) {
                    cachedConnections = updateConnectionsData();
                }
                const links = cachedConnections.slice(0, lod.maxConnectionsDrawn);

                // Batch draw connections for better performance at high N
                if (lod.batchDrawConnections) {
                    // ULTRA FAST MODE: Single path for all connections
                    ctx.beginPath();
                    ctx.strokeStyle = config.color;
                    ctx.globalAlpha = 0.2;
                    ctx.lineWidth = 1;
                    links.forEach(link => {
                        ctx.moveTo(link.source.x, link.source.y);
                        ctx.lineTo(link.target.x, link.target.y);
                    });
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                } else {
                    // NORMAL MODE: Individual connections with observer effects
                    if (currentObserver === 'ai') {
                        // AI: Variable thickness by semantic distance
                        links.forEach(link => {
                            const strength = 1 - (link.distance / config.connectionDistance);
                            ctx.strokeStyle = config.color;
                            ctx.globalAlpha = (1 - link.distance / config.connectionDistance) * 0.5;
                            ctx.lineWidth = 0.5 + strength * 3;
                            ctx.beginPath();
                            ctx.moveTo(link.source.x, link.source.y);
                            ctx.lineTo(link.target.x, link.target.y);
                            ctx.stroke();
                        });
                        ctx.globalAlpha = 1;
                    } else if (currentObserver === 'social') {
                        // Social: Only same-cluster connections
                        const sameClusterLinks = links.filter(l => l.source.cluster === l.target.cluster);
                        sameClusterLinks.forEach(link => {
                            ctx.strokeStyle = link.source.color;
                            ctx.globalAlpha = 0.4;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(link.source.x, link.source.y);
                            ctx.lineTo(link.target.x, link.target.y);
                            ctx.stroke();
                        });
                        ctx.globalAlpha = 1;
                    } else {
                        // Default connections
                        ctx.lineWidth = 1;
                        links.forEach(link => {
                            ctx.strokeStyle = config.color;
                            ctx.globalAlpha = (1 - link.distance / config.connectionDistance) * 0.3;
                            ctx.beginPath();
                            ctx.moveTo(link.source.x, link.source.y);
                            ctx.lineTo(link.target.x, link.target.y);
                            ctx.stroke();
                        });
                        ctx.globalAlpha = 1;
                    }
                }

                // === DRAW CLASSICAL TRAILS (LOD aware) ===
                if (currentObserver === 'classical' && lod.useTrails) {
                    particles.forEach(p => {
                        if (!p.trail) p.trail = [];
                        p.trail.push({x: p.x, y: p.y});
                        if (p.trail.length > 20) p.trail.shift();

                        if (p.trail.length > 1) {
                            ctx.strokeStyle = config.color;
                            ctx.globalAlpha = 0.3;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(p.trail[0].x, p.trail[0].y);
                            for (let i = 1; i < p.trail.length; i++) {
                                ctx.lineTo(p.trail[i].x, p.trail[i].y);
                            }
                            ctx.stroke();
                            ctx.globalAlpha = 1;
                        }
                    });
                }

                // === DRAW QUANTUM GHOSTS (LOD aware) ===
                if (currentObserver === 'quantum' && lod.useGhosts && window.ghostParticles) {
                    window.ghostParticles.forEach((ghost, i) => {
                        const parent = particles[ghost.parent];
                        if (parent) {
                            // Ghosts orbit parent
                            const angle = ghost.angle + (frameCount * 0.02);
                            const radius = 20 + Math.sin(frameCount * 0.05 + i) * 12;
                            ghost.x = parent.x + Math.cos(angle) * radius;
                            ghost.y = parent.y + Math.sin(angle) * radius;
                        }

                        // Draw ghost with optional glow
                        const opacity = 0.35 + Math.sin(frameCount * 0.05) * 0.15;
                        const ghostSize = lod.particleSize * (1.0 + Math.sin(frameCount * 0.03) * 0.3);

                        ctx.globalAlpha = opacity;
                        ctx.fillStyle = config.color;
                        ctx.strokeStyle = config.color;
                        ctx.lineWidth = 1;

                        // Glow only at low particle counts
                        if (lod.useGlow) {
                            ctx.shadowColor = config.color;
                            ctx.shadowBlur = 8;
                        }

                        ctx.beginPath();
                        ctx.arc(ghost.x, ghost.y, ghostSize, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();

                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                    });
                }

                // === CALCULATE CONSCIOUS PREDICTION ERRORS ===
                if (currentObserver === 'conscious') {
                    particles.forEach(p => {
                        // Initialize prediction if not set
                        if (!p.predictedX) {
                            p.predictedX = p.x;
                            p.predictedY = p.y;
                        }

                        // Calculate error between PREVIOUS prediction and ACTUAL current position
                        const error = Math.sqrt((p.predictedX - p.x)**2 + (p.predictedY - p.y)**2);
                        p.predictionError = error;

                        // Make NEW prediction for next frame (assuming constant velocity)
                        p.predictedX = p.x + p.vx;
                        p.predictedY = p.y + p.vy;
                    });
                }

                // === DRAW PARTICLES (LOD optimized + Observer Power) ===
                ctx.globalAlpha = 0.8;

                // Glow only at low particle counts (expensive!)
                if (lod.useGlow) {
                    ctx.shadowColor = config.color;
                    ctx.shadowBlur = 5;
                }

                // Observer Power coarse-graining
                const gridSize = computationalBudget < 100 ?
                    Math.max(5, Math.floor(50 - (computationalBudget / 100) * 45)) : 0;

                particles.forEach(p => {
                    let fillColor = config.color;

                    // Social: cluster colors
                    if (currentObserver === 'social') {
                        fillColor = p.color || config.color; // Fallback if color not set
                    }

                    // Conscious: error-based coloring
                    if (currentObserver === 'conscious') {
                        const errorIntensity = Math.min(p.predictionError / 5, 1);
                        fillColor = errorIntensity > 0.5 ? '#e74c3c' : config.color;
                    }

                    // Apply coarse-graining (quantization) if observer power < 100%
                    let drawX = p.x;
                    let drawY = p.y;
                    let drawSize = lod.particleSize;

                    if (gridSize > 0) {
                        // Snap to grid (coarse-grained observation)
                        drawX = Math.floor(p.x / gridSize) * gridSize + gridSize/2;
                        drawY = Math.floor(p.y / gridSize) * gridSize + gridSize/2;
                        drawSize = Math.max(3, gridSize / 8); // Bigger clusters at low power
                    }

                    ctx.fillStyle = fillColor;
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, drawSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Social: white stroke (always show for clarity!)
                    if (currentObserver === 'social') {
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;

                // === UPDATE MATH PANEL (Less frequently at high N) ===
                frameCount++;
                if (frameCount % lod.mathPanelUpdateInterval === 0) {
                    updateMathPanel();
                }

                animationFrameId = requestAnimationFrame(animate);
            }

            animate();
            updateMathPanel();
        }

        // ===== TIME EVOLUTION =====
        function toggleTimeEvolution() {
            timeEvolutionActive = !timeEvolutionActive;
            const playBtn = document.getElementById('playBtn');
            const playIcon = document.getElementById('playIcon');
            const playText = document.getElementById('playText');

            if (timeEvolutionActive) {
                playBtn.style.background = '#e74c3c';
                playBtn.style.color = 'white';
                playIcon.textContent = '‚è∏Ô∏è';
                playText.textContent = 'Pause';
            } else {
                playBtn.style.background = '#00ff88';
                playBtn.style.color = '#0a0e27';
                playIcon.textContent = '‚ñ∂Ô∏è';
                playText.textContent = 'Play';
            }
        }

        function updateSpeed(value) {
            evolutionSpeed = parseInt(value);
            document.getElementById('speedValue').textContent = value + 'x';
        }

        // ===== HEAT CONTROL =====
        function addHeat() {
            // Add heat = increase kinetic energy = increase particle velocities
            const particles = window.currentParticles || [];
            const heatFactor = 1.3; // 30% velocity increase

            particles.forEach(p => {
                p.vx *= heatFactor;
                p.vy *= heatFactor;
            });

            // Update calculations immediately
            updateMathPanel(true);

            // Show notification
            showNotification('üî• Heat Added! Temperature & Entropy Increasing', '#e74c3c');
        }

        function removeHeat() {
            // Remove heat = decrease kinetic energy = decrease particle velocities
            const particles = window.currentParticles || [];
            const coolFactor = 0.7; // 30% velocity decrease

            particles.forEach(p => {
                p.vx *= coolFactor;
                p.vy *= coolFactor;
            });

            // Update calculations immediately
            updateMathPanel(true);

            // Show notification
            showNotification('‚ùÑÔ∏è System Cooled! Temperature Decreasing', '#3498db');
        }

        function showNotification(message, color) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: ${color};
                color: white;
                padding: 20px 40px;
                border-radius: 12px;
                font-size: 1.2em;
                font-weight: 700;
                z-index: 10000;
                box-shadow: 0 0 40px ${color};
                animation: pulse 0.5s ease-out;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 1500);
        }

        // ===== POPULATION CONTROL =====
        function updatePopulation(value) {
            populationSize = parseInt(value);
            document.getElementById('populationValue').textContent = value;

            // Update unified monitor
            document.getElementById('popDisplay').textContent = value;

            // Recreate reality with new population
            createReality();

            // Show cascade effect
            setTimeout(() => updateMathPanel(true), 300);
        }

        // Update connections and store for math calculations
        // OPTIMIZED with spatial grid partitioning!
        function updateConnectionsData() {
            const particles = window.currentParticles || [];
            const config = observerConfigs[currentObserver];
            const links = [];

            // MAX CONNECTIONS to prevent lag at high N
            const MAX_CONNECTIONS = 2000;

            // === SPATIAL GRID OPTIMIZATION ===
            // Only check particles in nearby grid cells (O(N) instead of O(N¬≤)!)
            const cellSize = config.connectionDistance;
            const canvasWidth = window.canvasWidth || 1200;
            const canvasHeight = window.canvasHeight || 800;
            const grid = {};

            // Assign particles to grid cells
            particles.forEach(p => {
                const cellX = Math.floor(p.x / cellSize);
                const cellY = Math.floor(p.y / cellSize);
                const cellKey = `${cellX},${cellY}`;

                if (!grid[cellKey]) grid[cellKey] = [];
                grid[cellKey].push(p);
            });

            // Check each particle only against nearby cells (3x3 neighborhood)
            particles.forEach(p => {
                const cellX = Math.floor(p.x / cellSize);
                const cellY = Math.floor(p.y / cellSize);

                // Check 9 nearby cells (including current)
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const neighborKey = `${cellX + dx},${cellY + dy}`;
                        const neighbors = grid[neighborKey] || [];

                        neighbors.forEach(neighbor => {
                            // Avoid duplicate connections
                            if (p.id < neighbor.id) {
                                const deltaX = p.x - neighbor.x;
                                const deltaY = p.y - neighbor.y;
                                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                                if (distance < config.connectionDistance && distance > 0) {
                                    links.push({
                                        source: p,
                                        target: neighbor,
                                        distance: distance
                                    });

                                    // Stop if we hit max connections (prevent lag)
                                    if (links.length >= MAX_CONNECTIONS) return;
                                }
                            }
                        });

                        if (links.length >= MAX_CONNECTIONS) break;
                    }
                    if (links.length >= MAX_CONNECTIONS) break;
                }
            });

            window.currentConnections = links;
            return links;
        }

        // ===== TOOLTIP CLICK HANDLERS =====
        document.addEventListener('click', function(e) {
            // Close all tooltips first
            if (!e.target.closest('.tooltip-icon') && !e.target.closest('.stat-row-hover')) {
                document.querySelectorAll('.tooltip-icon.active').forEach(el => el.classList.remove('active'));
                document.querySelectorAll('.stat-row-hover.active').forEach(el => el.classList.remove('active'));
            }

            // Toggle tooltip on click
            if (e.target.closest('.tooltip-icon')) {
                e.stopPropagation();
                const tooltip = e.target.closest('.tooltip-icon');
                tooltip.classList.toggle('active');
            }

            // Toggle stat tooltip on click
            if (e.target.closest('.stat-row-hover')) {
                e.stopPropagation();
                const statRow = e.target.closest('.stat-row-hover');
                statRow.classList.toggle('active');
            }
        });

        // ===== INFO MODAL =====
        document.getElementById('infoModalBtn').addEventListener('click', function() {
            document.getElementById('infoModal').style.display = 'block';
        });

        // Close modal when clicking backdrop
        document.getElementById('infoModal').addEventListener('click', function(e) {
            if (e.target === this) {
                this.style.display = 'none';
            }
        });

        // ===== INITIALIZATION =====
        window.addEventListener('resize', createReality);
        createReality();
    </script>
</body>
</html>
