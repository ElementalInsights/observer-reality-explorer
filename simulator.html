<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reality Simulator - Observer Lens</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0e27;
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        /* Compact Top Bar */
        .top-bar {
            background: linear-gradient(135deg, #1a1f3a 0%, #0a0e27 100%);
            padding: 15px 20px;
            border-bottom: 2px solid #00ff88;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .top-bar h1 {
            font-size: 1.3em;
            color: #00ff88;
            margin: 0;
        }

        .top-bar a {
            color: #888;
            text-decoration: none;
            font-size: 0.9em;
            transition: color 0.2s;
        }

        .top-bar a:hover {
            color: #00ff88;
        }

        /* Main Canvas */
        .main-canvas {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 40px;
            display: grid;
            grid-template-columns: 420px 1fr 380px;
            gap: 20px;
            padding: 40px;
        }

        /* Visualization Container (center, row 2) */
        .viz-container {
            grid-column: 2;
            grid-row: 2;
            background: rgba(255,255,255,0.03);
            border-radius: 20px;
            border: 2px solid rgba(0,255,136,0.2);
            padding: 0;
            position: relative;
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        /* Math Panel (left side, row 2) */
        .math-panel {
            grid-column: 1;
            grid-row: 2;
            background: rgba(10,14,39,0.95);
            border-radius: 20px;
            border: 2px solid rgba(0,255,136,0.2);
            padding: 20px;
            backdrop-filter: blur(10px);
            overflow-y: auto;
        }

        .math-panel h2 {
            color: #00ff88;
            font-size: 1.2em;
            margin: 0 0 15px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid #00ff88;
        }

        /* Controls Panel (right side, row 2) */
        .controls-panel {
            grid-column: 3;
            grid-row: 2;
            background: rgba(10,14,39,0.95);
            border-radius: 20px;
            border: 2px solid rgba(0,255,136,0.2);
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .controls-panel h2 {
            color: #00ff88;
            font-size: 1.2em;
            margin: 0 0 15px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid #00ff88;
        }

        .controls-panel h2,
        .math-row h2 {
            color: #00ff88;
            font-size: 1.2em;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #00ff88;
        }

        /* Controls Section */
        .control-section {
            background: rgba(0,255,136,0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0,255,136,0.2);
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: #00ff88;
            font-size: 0.9em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .observer-select {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 12px;
        }

        .observer-select button {
            padding: 8px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            color: white;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .observer-select button:hover {
            background: rgba(255,255,255,0.1);
        }

        .observer-select button.active {
            background: #00ff88;
            color: #0a0e27;
            border-color: #00ff88;
            font-weight: 700;
        }

        .control-row {
            margin: 10px 0;
        }

        .control-row label {
            display: block;
            font-size: 1em;
            color: #aaa;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .control-row input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .control-values {
            display: flex;
            justify-content: space-between;
            font-size: 1em;
            color: #00ff88;
            font-weight: 500;
        }

        .math-section {
            margin-bottom: 25px;
        }

        .math-section h3 {
            color: #00ff88;
            font-size: 1em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .formula {
            background: rgba(0,255,136,0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #00ff88;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.8;
        }

        .formula-label {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 5px;
        }

        .formula-value {
            color: #00ff88;
            font-weight: 700;
            font-size: 1.1em;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            position: relative;
        }

        .metric-label {
            color: #aaa;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 1em;
            margin-bottom: 6px;
        }

        .metric-value {
            color: #00ff88;
            font-weight: 700;
            font-size: 1.1em;
        }

        /* Tooltip System */
        .tooltip-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background: rgba(0,255,136,0.3);
            border: 1px solid #00ff88;
            border-radius: 50%;
            text-align: center;
            line-height: 14px;
            font-size: 0.7em;
            color: #00ff88;
            cursor: help;
            position: relative;
        }

        .tooltip-icon:hover {
            background: rgba(0,255,136,0.5);
        }

        .tooltip-content {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10,14,39,0.98);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 16px;
            width: 500px;
            z-index: 2000;
            box-shadow: 0 4px 30px rgba(0,255,136,0.6);
        }

        .tooltip-icon.active .tooltip-content {
            display: block;
        }

        .tooltip-content h4 {
            color: #00ff88;
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }

        .tooltip-content p {
            color: #ddd;
            margin: 8px 0;
            font-size: 1.05em;
            line-height: 1.6;
        }

        .tooltip-content .why {
            color: #9b59b6;
            font-weight: 600;
            margin-top: 10px;
            font-size: 1em;
        }

        .math-panel::-webkit-scrollbar {
            width: 8px;
        }

        .math-panel::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
        }

        .math-panel::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 4px;
        }

        /* Cascade Effect Animation */
        @keyframes cascade-pulse {
            0% {
                background: rgba(0,255,136,0.1);
                transform: scale(1);
            }
            50% {
                background: rgba(0,255,136,0.3);
                transform: scale(1.02);
            }
            100% {
                background: rgba(0,255,136,0.1);
                transform: scale(1);
            }
        }

        .cascade-active {
            animation: cascade-pulse 0.6s ease-out;
        }

        .cascade-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,255,136,0.2);
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid #00ff88;
            font-size: 0.85em;
            color: #00ff88;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .cascade-indicator.active {
            opacity: 1;
        }

        /* Heat Monitor Tooltip */
        .heat-monitor {
            cursor: help;
        }

        .heat-tooltip {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: rgba(10,14,39,0.98);
            border: 2px solid #e74c3c;
            border-radius: 10px;
            padding: 16px;
            width: 420px;
            z-index: 1000;
            margin-top: 5px;
            box-shadow: 0 4px 20px rgba(231,76,60,0.4);
        }

        .heat-monitor:hover .heat-tooltip {
            display: block;
        }

        .heat-tooltip h4 {
            color: #e74c3c;
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }

        .heat-tooltip p {
            color: #ddd;
            margin: 6px 0;
            font-size: 0.95em;
            line-height: 1.6;
        }

        .heat-tooltip .why {
            color: #f39c12;
            font-weight: 600;
            margin-top: 10px;
            font-size: 1em;
        }

        /* Collapse animation */
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* Reality Grid - Optimized! */
        #reality-canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 18px;
        }

        /* Observer Info Card (row above canvas) */
        .observer-info-card {
            grid-column: 1 / -1;
            grid-row: 1;
            background: rgba(10,14,39,0.92);
            border: 2px solid rgba(0,255,136,0.5);
            border-radius: 12px;
            padding: 20px 28px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
        }

        .observer-name {
            color: #00ff88;
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .observer-desc-inline {
            color: #00ff88;
            font-size: 1em;
            line-height: 1.5;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .observer-description {
            color: #ccc;
            font-size: 1.1em;
            line-height: 1.6;
            padding: 0;
        }

        /* Live Stats Grid */
        .live-stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .live-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(0,255,136,0.05);
            border-radius: 6px;
            border: 1px solid rgba(0,255,136,0.15);
            position: relative;
        }

        .live-stat-label {
            color: #888;
            font-size: 1em;
        }

        .live-stat-value {
            color: #00ff88;
            font-weight: 700;
            font-size: 1.1em;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 6px 0;
            position: relative;
        }

        .stat-row-hover {
            cursor: pointer;
        }

        .stat-row-hover.active {
            background: rgba(155,89,182,0.1);
        }

        .stat-tooltip {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10,14,39,0.98);
            border: 2px solid #9b59b6;
            border-radius: 10px;
            padding: 16px;
            width: 500px;
            z-index: 2000;
            box-shadow: 0 4px 30px rgba(155,89,182,0.6);
        }

        .stat-row-hover.active .stat-tooltip {
            display: block;
        }

        .stat-tooltip h4 {
            color: #9b59b6;
            margin: 0 0 10px 0;
            font-size: 1em;
        }

        .stat-tooltip p {
            color: #ddd;
            margin: 8px 0;
            font-size: 1.05em;
            line-height: 1.6;
        }

        .stat-tooltip .why {
            color: #f39c12;
            font-weight: 600;
            margin-top: 10px;
        }

        .stat-label {
            color: #888;
            font-size: 0.9em;
        }

        .stat-value {
            color: #00ff88;
            font-weight: 700;
            font-size: 0.95em;
        }

        .perf-fps {
            color: #27ae60;
        }

        .perf-lod {
            color: #f39c12;
        }

        .perf-effects {
            color: #9b59b6;
        }

        .info-display p {
            color: #aaa;
            font-size: 0.85em;
            line-height: 1.6;
            margin: 5px 0;
        }

        .info-display .emphasis {
            color: #00ff88;
            font-weight: 600;
        }

        /* Heat Monitor */
        .heat-monitor {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 12px 18px;
            border-radius: 10px;
            border-left: 4px solid #e74c3c;
            min-width: 180px;
        }

        .perf-monitor {
            position: absolute;
            top: 150px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 12px 18px;
            border-radius: 10px;
            border-left: 4px solid #9b59b6;
            min-width: 180px;
            font-size: 0.85em;
        }

        .perf-monitor .perf-label {
            color: #9b59b6;
            font-weight: 700;
            margin-bottom: 6px;
        }

        .perf-monitor .perf-row {
            color: #aaa;
            margin: 4px 0;
            display: flex;
            justify-content: space-between;
        }

        .perf-monitor .perf-row .perf-value {
            color: #00ff88;
            font-weight: 600;
        }

        .lod-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 700;
            margin-left: 5px;
        }

        .lod-ultra { background: #27ae60; color: white; }
        .lod-high { background: #f39c12; color: white; }
        .lod-medium { background: #e74c3c; color: white; }
        .lod-fast { background: #9b59b6; color: white; }

        .heat-label {
            color: #e74c3c;
            font-size: 0.9em;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .heat-bar-container {
            width: 100%;
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .heat-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #3498db 0%, #00ff88 30%, #f39c12 60%, #e74c3c 100%);
            transition: width 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 0 10px rgba(231,76,60,0.5);
        }

        .heat-value {
            color: #fff;
            font-size: 0.85em;
            font-weight: 600;
            text-align: center;
        }

        /* Footer */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(10,14,39,0.9);
            padding: 10px 20px;
            text-align: center;
            font-size: 0.8em;
            color: #666;
            border-top: 1px solid rgba(0,255,136,0.2);
        }

        .footer a {
            color: #00ff88;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <!-- Compact Top Bar -->
    <div class="top-bar">
        <h1>🔬 Reality Observer Simulator</h1>
        <a href="index.html">← Back to Theory</a>
    </div>

    <!-- Main Visualization -->
    <div class="main-canvas">
        <!-- System State & Calculations (left column) -->
        <div class="math-panel">
            <h2>📊 System State</h2>

                <!-- Live System Stats -->
                <div class="live-stats-grid">
                    <div class="live-stat stat-row-hover">
                        <span class="live-stat-label">Population:</span>
                        <span class="live-stat-value" id="popDisplay">20</span>
                        <div class="stat-tooltip">
                            <h4>📊 Population Size (N)</h4>
                            <p><strong>Statistical Mechanics:</strong> As N increases, individual randomness averages out and collective behavior emerges!</p>
                            <p class="why">Scale Effects:</p>
                            <p>• <strong>Small N (10-100):</strong> See individual particles, random fluctuations dominate<br>
                            • <strong>Medium N (100-1000):</strong> Patterns start emerging, statistics become reliable<br>
                            • <strong>Large N (1000+):</strong> Thermodynamic laws emerge (entropy always increases, diffusion, equilibration)</p>
                            <p class="why">Coarse-Graining:</p>
                            <p>At high N, we can't track every particle! Use <strong>Observer Power</strong> slider to simulate limited resolution. Low power = coarse-grained view (particles appear as blobs).</p>
                            <p class="why">Real-world analogy:</p>
                            <p>A single water molecule is chaotic. A billion molecules? That's a wave with predictable physics!</p>
                        </div>
                    </div>
                    <div class="live-stat">
                        <span class="live-stat-label">Temperature:</span>
                        <span class="live-stat-value" id="tempDisplay">T = 0.000</span>
                    </div>
                    <div class="live-stat">
                        <span class="live-stat-label">FPS:</span>
                        <span class="live-stat-value perf-fps" id="fpsValue">60</span>
                    </div>
                    <div class="live-stat">
                        <span class="live-stat-label">LOD:</span>
                        <span class="live-stat-value perf-lod" id="lodMode">HIGH</span>
                    </div>
                    <div class="live-stat">
                        <span class="live-stat-label">Effects:</span>
                        <span class="live-stat-value perf-effects" id="effectsActive">ALL</span>
                    </div>
                </div>

                <div style="height: 1px; background: rgba(0,255,136,0.2); margin: 15px 0;"></div>

            <div class="math-section">
                <div class="metric">
                    <span class="metric-label">
                        Particles (N):
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Population Size (N)</h4>
                                <p>The total number of entities in your system - could be particles, people, neurons, or concepts.</p>
                                <p class="why">Why it matters:</p>
                                <p>Larger N means more complexity, more interactions, and exponentially higher computational costs (N² scaling). In real systems, observers can't track everything!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="particleCount">0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">
                        Connections (E):
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Network Edges (E)</h4>
                                <p>Number of active relationships between particles within connection distance. Forms the network topology.</p>
                                <p class="why">Why it matters:</p>
                                <p>High E means highly interconnected system (social clusters, quantum entanglement). Low E means isolated particles. Network structure determines information flow!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="connectionCount">0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">
                        Observer Power:
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Computational Budget</h4>
                                <p>How much resolution your observer has. Low power = coarse-grained view (particles snap to grid). High power = fine-grained precision.</p>
                                <p class="why">Why it matters:</p>
                                <p>Real observers (humans, AI, instruments) have LIMITED compute! You can't measure everything perfectly. Trade-off between detail and cost.</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="observerPower">100%</span>
                </div>

                <div style="height: 1px; background: rgba(0,255,136,0.2); margin: 15px 0;"></div>

                <div class="metric">
                    <span class="metric-label">
                        Shannon Entropy (H):
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Shannon Entropy (Information Theory)</h4>
                                <p><strong>H = -Σ p(x) log₂ p(x)</strong></p>
                                <p>Measures disorder/unpredictability. We divide space into grid cells and calculate probability distribution. Higher H = more spread out, more random.</p>
                                <p class="why">Why it matters:</p>
                                <p>2nd Law of Thermodynamics: entropy ALWAYS increases in closed systems! Watch it grow when you hit Play. Core to information theory, physics, and ML.</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="entropyValue">0.000 bits</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    H = -Σ p(x) log₂ p(x) | From 2D spatial distribution
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Uncertainty (Δx·Δp):
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Heisenberg Uncertainty Principle</h4>
                                <p><strong>Δx · Δp ≥ ℏ/2</strong></p>
                                <p>Product of position variance (σₓ) and velocity variance (σₚ). You can't know both precisely at once!</p>
                                <p class="why">Why it matters:</p>
                                <p>Fundamental limit in quantum mechanics. Trade-off between knowing WHERE something is vs HOW FAST it's moving. Quantum observers see higher uncertainty than classical!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="uncertaintyValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    σ_pos × σ_vel | Position & velocity variance
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Network Density (ρ):
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Graph Density</h4>
                                <p><strong>ρ = 2E / N(N-1)</strong></p>
                                <p>Ratio of actual connections to maximum possible connections. ρ=1 means fully connected (every particle connects to every other), ρ=0 means totally isolated.</p>
                                <p class="why">Why it matters:</p>
                                <p>Determines information flow speed, system robustness, phase transitions. Social networks: high ρ = echo chambers. Neural networks: connectivity = computational power!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="densityValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    2E / N(N-1) | Actual vs possible connections
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Computational Cost (C):
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Algorithmic Complexity</h4>
                                <p><strong>C = N²</strong></p>
                                <p>Number of pairwise distance calculations per frame. Checking every particle against every other = O(N²) scaling.</p>
                                <p class="why">Why it matters:</p>
                                <p>This is WHY coarse-graining exists! Real systems (brains, GPUs, nature) can't compute everything. Limits to observation = fundamental to reality. Watch C explode as N increases!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="complexityValue">0 ops</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    N² | Pairwise distance calculations per frame
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Free Energy (F):
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Helmholtz Free Energy</h4>
                                <p><strong>F = U - TS</strong></p>
                                <p>Combines potential energy (U) with entropy (S) and temperature (T). Lower F = more stable configuration.</p>
                                <p class="why">Why it matters:</p>
                                <p>Systems minimize free energy! Brains use "Free Energy Principle" (Karl Friston). Connects thermodynamics to prediction, consciousness, and life itself. Active inference = minimize surprise!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="freeEnergyValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    U - TS | Potential energy minus entropy term
                </p>

                <div style="height: 1px; background: rgba(0,255,136,0.2); margin: 15px 0;"></div>

                <div class="metric">
                    <span class="metric-label">
                        Temperature (T):
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Thermodynamic Temperature</h4>
                                <p><strong>T ∝ √(⟨v²⟩)</strong></p>
                                <p>Derived from kinetic energy. Higher T = faster particles = more thermal motion.</p>
                                <p class="why">Why it matters:</p>
                                <p>Temperature drives entropy growth! Hot systems are chaotic, cold systems can form structure. Controls phase transitions (solid→liquid→gas). Heat = randomness!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="temperatureValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    √(⟨v²⟩) | From kinetic energy/velocity variance
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Kinetic Energy (K):
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Kinetic Energy (Motion)</h4>
                                <p><strong>K = ½mv²</strong></p>
                                <p>Energy of motion. Sum of all particle velocities squared.</p>
                                <p class="why">Why it matters:</p>
                                <p>Half of total energy (K+U). Can be converted to potential energy and back. Conservation of energy = fundamental law. Kinetic energy IS heat in statistical mechanics!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="kineticValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    ⟨½mv²⟩ | Average kinetic energy per particle
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Potential Energy (U):
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Potential Energy (Interactions)</h4>
                                <p>Energy stored in particle interactions. Lennard-Jones potential: attractive at medium range, repulsive up close.</p>
                                <p class="why">Why it matters:</p>
                                <p>Determines stable configurations! Low U = particles found their "happy distance". Molecular bonds, galaxies, social networks - all minimize potential energy.</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="potentialValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    Lennard-Jones | Particle interaction energy
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Spatial Spread (σᵣ):
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Root Mean Square Spread</h4>
                                <p>Average distance from center of mass. Measures how "puffed out" the system is.</p>
                                <p class="why">Why it matters:</p>
                                <p>Grows with entropy! When you hit Play, watch particles diffuse outward. 2nd law in action. Star formation, gas clouds, crowd dispersion - all follow this!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="spatialSpreadValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    RMS distance from center of mass
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Info Deficit (ΔH):
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Information Deficit</h4>
                                <p><strong>ΔH = H_max - H</strong></p>
                                <p>How much entropy remains before reaching maximum disorder (uniform distribution).</p>
                                <p class="why">Why it matters:</p>
                                <p>Measures available "structure" or "order" in the system. High ΔH = still organized. Low ΔH = approaching heat death! Information = negative entropy (negentropy).</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="infoDeficitValue">0.000 bits</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    H_max - H | Distance from maximum entropy
                </p>

                <div class="metric">
                    <span class="metric-label">
                        Avg Velocity (⟨v⟩):
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Mean Particle Speed</h4>
                                <p>Average velocity magnitude across all particles. Proxy for system momentum.</p>
                                <p class="why">Why it matters:</p>
                                <p>Related to temperature and kinetic energy. Fast particles = hot system. Shows how "active" the system is. Zero mean velocity = no net drift.</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="avgVelocityValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    Mean particle speed | System momentum
                </p>

                <div style="height: 1px; background: rgba(0,255,136,0.2); margin: 15px 0;"></div>

                <div class="metric">
                    <span class="metric-label">
                        Total Energy (E_total):
                        <span class="tooltip-icon">?
                            <span class="tooltip-content">
                                <h4>Total System Energy</h4>
                                <p><strong>E_total = K + U</strong></p>
                                <p>Sum of kinetic energy (motion) and potential energy (interactions). Should be conserved in isolated systems!</p>
                                <p class="why">Why it matters:</p>
                                <p>First Law of Thermodynamics: energy is conserved. Watch it stay constant (with slight numerical drift). Energy can flow between K↔U but total stays fixed. Foundation of physics!</p>
                            </span>
                        </span>
                    </span>
                    <span class="metric-value" id="totalEnergyValue">0.000</span>
                </div>
                <p style="color: #888; font-size: 0.95em; margin: 5px 0 12px 0;">
                    K + U | Conserved in closed systems
                </p>
            </div>
        </div>

        <!-- Observer Card (full width row above everything) -->
        <div class="observer-info-card" id="observerCard">
            <div style="display: flex; gap: 30px; align-items: center;">
                <!-- Observer Info (left side) -->
                <div style="flex: 1; text-align: left;">
                    <div class="observer-name" id="observerTitle">🌀 Quantum Observer</div>
                    <div class="observer-desc-inline" id="observerDesc">Superpositions, Multiple States, Probabilistic Reality</div>
                    <div class="observer-description" id="observerDescription">
                        Sees particles in MULTIPLE states at once. Reality is probabilistic - particles exist as "waves" until measured. Ghost particles show superposition states.
                    </div>
                </div>

                <!-- Play Button (right side) -->
                <div style="text-align: center;">
                    <button id="playBtn" onclick="toggleTimeEvolution()" style="padding: 15px 40px; background: #00ff88; color: #0a0e27; border: none; border-radius: 8px; font-weight: 700; cursor: pointer; font-size: 1.2em; box-shadow: 0 4px 15px rgba(0,255,136,0.4); margin-bottom: 8px; display: block;">
                        <span id="playIcon">▶️</span> <span id="playText">Play</span>
                    </button>
                    <div style="color: #aaa; font-size: 1em; line-height: 1.5;">
                        See entropy increase,<br>particles spread!
                    </div>
                </div>
            </div>
        </div>

        <!-- Canvas (center) -->
        <div class="viz-container">
            <canvas id="reality-canvas"></canvas>
        </div>

        <!-- Controls (right column) -->
        <div class="controls-panel">
            <div class="cascade-indicator" id="cascadeIndicator">⚡ Cascade Update</div>
            <h2>Controls</h2>

                <!-- CONTROLS -->
                <div class="control-section">
                <h3>Observer Type</h3>
                <div class="observer-select">
                    <button class="active" data-observer="quantum" onclick="switchObserver('quantum')">🔬 Quantum</button>
                    <button data-observer="classical" onclick="switchObserver('classical')">🎯 Classical</button>
                    <button data-observer="social" onclick="switchObserver('social')">🌐 Social</button>
                    <button data-observer="conscious" onclick="switchObserver('conscious')">🧠 Conscious</button>
                    <button data-observer="ai" onclick="switchObserver('ai')">🤖 AI</button>
                </div>

                <div class="control-row">
                    <label>Population Size (N) - LOD Optimized ⚡</label>
                    <input type="range" id="populationSlider" min="20" max="1000" value="20" step="20" oninput="updatePopulation(this.value)">
                    <div class="control-values">
                        <span>20</span>
                        <span id="populationValue">20</span>
                        <span style="color: #00ff88; font-weight: 700;">1k</span>
                    </div>
                    <p style="color: #888; font-size: 0.95em; margin-top: 8px; line-height: 1.5;">
                        🚀 GPU-accelerated! Scale up to see emergent patterns at massive scale!
                    </p>
                </div>

                <div class="control-row">
                    <label>Observer Power (Coarse-graining)</label>
                    <input type="range" id="budgetSlider" min="0" max="100" value="100" oninput="updateBudget(this.value)">
                    <div class="control-values">
                        <span>Coarse</span>
                        <span id="budgetValue">100%</span>
                        <span>Fine</span>
                    </div>
                </div>

                <div class="control-row">
                    <label>Evolution Speed</label>
                    <input type="range" id="speedSlider" min="1" max="10" value="5" oninput="updateSpeed(this.value)" style="width: 100%;">
                    <div class="control-values">
                        <span>Slow</span>
                        <span id="speedValue">5x</span>
                        <span>Fast</span>
                    </div>
                    <p style="color: #888; font-size: 0.95em; margin-top: 8px; line-height: 1.5;">
                        How fast particles spread and entropy increases
                    </p>
                </div>

                <div class="control-row">
                    <label>Heat Control (Add/Remove Energy)</label>
                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                        <button onclick="addHeat()" style="flex: 1; padding: 12px; background: #e74c3c; color: white; border: none; border-radius: 6px; font-weight: 700; cursor: pointer; font-size: 1em;">
                            🔥 Add Heat
                        </button>
                        <button onclick="removeHeat()" style="flex: 1; padding: 12px; background: #3498db; color: white; border: none; border-radius: 6px; font-weight: 700; cursor: pointer; font-size: 1em;">
                            ❄️ Cool Down
                        </button>
                    </div>
                    <p style="color: #888; font-size: 0.95em; margin-top: 8px; line-height: 1.5;">
                        Heat = kinetic energy. Watch Temperature, K, and Entropy increase with heat!
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <div class="footer">
        © 2025 Jacob Edwards | <a href="index.html">← Back to Theory</a> | <a href="https://github.com/ElementalInsights/observer-reality-explorer" target="_blank">GitHub</a>
    </div>

    <script>
        // ===== STATE =====
        let currentObserver = 'quantum';
        let computationalBudget = 100;
        let timeEvolutionActive = false;
        let evolutionSpeed = 5;
        let evolutionTime = 0;
        let populationSize = 20;
        let animationFrameId = null;

        const observerConfigs = {
            quantum: {
                name: '🌀 Quantum Observer',
                color: '#9b59b6',
                description: 'Sees particles in MULTIPLE states at once (superposition). Reality is probabilistic - particles exist as "waves" of possibility until measured. Ghost particles show "HERE or THERE" states before observation collapses the wave function.',
                emphasis: 'Superpositions, Multiple States, Probabilistic Reality, Wave Function Collapse',
                particleSize: 3,
                connectionDistance: 100,
                showUncertainty: true,
                showSuperposition: true
            },
            classical: {
                name: '🎯 Classical Observer',
                color: '#3498db',
                description: 'Sees particles with EXACT positions and velocities. Reality is deterministic - if you know the initial conditions, you can predict the future perfectly. Trajectory trails show precise paths through spacetime. Newtonian mechanics.',
                emphasis: 'Determinism, Single Definite States, Predictable Trajectories, Perfect Certainty',
                particleSize: 5,
                connectionDistance: 150,
                showUncertainty: false,
                showSuperposition: false
            },
            social: {
                name: '🌐 Social Observer',
                color: '#27ae60',
                description: 'Sees CLUSTERS and group membership. Reality is relational - entities are defined by their tribal affiliations. Connections only form within groups (echo chambers!). Different colors = different social identities. Us vs Them.',
                emphasis: 'Groups, Tribes, In-groups vs Out-groups, Echo Chambers, Identity',
                particleSize: 7,
                connectionDistance: 120,
                showClusters: true,
                clusterCount: 5
            },
            conscious: {
                name: '🧠 Conscious Observer',
                color: '#e67e22',
                description: 'Sees PREDICTION ERRORS and surprises. Reality is about minimizing free energy (surprise). Red particles = high prediction error (unexpected!). Consciousness emerges from integrating information to predict and control. Active inference.',
                emphasis: 'Prediction Errors, Free Energy Minimization, Integrated Information, Active Inference',
                particleSize: 4,
                connectionDistance: 110,
                showFlows: true
            },
            ai: {
                name: '🤖 AI Observer',
                color: '#1abc9c',
                description: 'Sees SEMANTIC RELATIONSHIPS in high-dimensional embedding space. Reality is vectors - closer particles = more similar meaning. Connection thickness shows semantic similarity. Like word2vec, transformers, or neural network attention.',
                emphasis: 'Embeddings, Semantic Distance, Vector Space, Attention Weights',
                particleSize: 3,
                connectionDistance: 90,
                showVectors: true
            }
        };

        // ===== OBSERVER SWITCHING =====
        function switchObserver(observerType) {
            const previousObserver = currentObserver;
            currentObserver = observerType;
            const config = observerConfigs[observerType];

            // Update button states
            document.querySelectorAll('.observer-select button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update info display
            const infoDisplay = document.getElementById('infoDisplay');
            // Update observer info display
            document.getElementById('observerTitle').textContent = config.name;
            document.getElementById('observerDesc').textContent = config.emphasis;
            document.getElementById('observerDescription').textContent = config.description;

            // === WAVE FUNCTION COLLAPSE! ===
            if (previousObserver === 'quantum' && observerType !== 'quantum') {
                // Switching FROM quantum to anything else = MEASUREMENT
                // Superpositions collapse into definite states
                collapseWaveFunction(() => {
                    // Update visualization without regenerating particles
                    updateObserverVisualization();
                    setTimeout(() => updateMathPanel(true), 500);
                });
            } else if (window.currentParticles && window.currentParticles.length === populationSize) {
                // Particles exist, just update visualization
                updateObserverVisualization();
                setTimeout(() => updateMathPanel(true), 500);
            } else {
                // First load or population changed - create new particles
                createReality();
                setTimeout(() => updateMathPanel(true), 500);
            }
        }

        // Wave function collapse animation
        function collapseWaveFunction(callback) {
            const ghosts = d3.selectAll('.ghosts circle');
            const particles = d3.selectAll('.particles circle');

            // Show collapse notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(155, 89, 182, 0.95);
                color: white;
                padding: 30px 50px;
                border-radius: 15px;
                font-size: 1.5em;
                font-weight: 700;
                z-index: 10000;
                box-shadow: 0 0 50px rgba(155, 89, 182, 0.8);
                animation: pulse 0.5s ease-out;
            `;
            notification.innerHTML = '⚡ WAVE FUNCTION COLLAPSE ⚡<br><span style="font-size: 0.6em;">Superpositions → Definite State</span>';
            document.body.appendChild(notification);

            // Animate ghosts collapsing into particles
            ghosts.transition()
                .duration(800)
                .attr('r', 0)
                .attr('opacity', 0);

            // Pulse particles
            particles.transition()
                .duration(300)
                .attr('r', d => observerConfigs[currentObserver].particleSize * 2)
                .transition()
                .duration(300)
                .attr('r', d => observerConfigs[currentObserver].particleSize);

            setTimeout(() => {
                notification.remove();
                callback();
            }, 1000);
        }

        // ===== COMPUTATIONAL BUDGET =====
        function updateBudget(value) {
            computationalBudget = parseInt(value);
            document.getElementById('budgetValue').textContent = value + '%';
            document.getElementById('observerPower').textContent = value + '%';

            // Coarse-graining now handled in Canvas rendering (no D3 needed!)
            // The animation loop will apply quantization based on computationalBudget

            // Update math panel with CASCADE effect
            updateMathPanel(true);
        }

        // ===== UPDATE MATH PANEL =====
        function updateMathPanel(showCascade = false) {
            const config = observerConfigs[currentObserver];
            const particles = window.currentParticles || [];
            const connections = window.currentConnections || [];

            // Show cascade indicator if requested
            if (showCascade) {
                const indicator = document.getElementById('cascadeIndicator');
                indicator.classList.add('active');
                setTimeout(() => indicator.classList.remove('active'), 1500);

                // Animate each math section
                document.querySelectorAll('.math-section').forEach((section, i) => {
                    setTimeout(() => {
                        section.classList.add('cascade-active');
                        setTimeout(() => section.classList.remove('cascade-active'), 600);
                    }, i * 100);
                });
            }

            // Particle count
            document.getElementById('particleCount').textContent = particles.length;

            // Connection count
            document.getElementById('connectionCount').textContent = connections.length;

            // Shannon Entropy - REAL calculation from 2D spatial distribution
            let entropy = 0;
            if (particles.length > 0) {
                // Create 2D grid based on observer power (coarse-graining)
                const gridResolution = Math.max(5, Math.floor(20 * (computationalBudget / 100)));
                const width = 1000;
                const height = 600;
                const cellWidth = width / gridResolution;
                const cellHeight = height / gridResolution;

                // Count particles in each cell
                const grid = new Array(gridResolution * gridResolution).fill(0);

                particles.forEach(p => {
                    const cellX = Math.min(Math.floor(p.x / cellWidth), gridResolution - 1);
                    const cellY = Math.min(Math.floor(p.y / cellHeight), gridResolution - 1);
                    const cellIndex = cellY * gridResolution + cellX;
                    grid[cellIndex]++;
                });

                // Calculate Shannon entropy from probability distribution
                const totalParticles = particles.length;
                grid.forEach(count => {
                    if (count > 0) {
                        const probability = count / totalParticles;
                        entropy -= probability * Math.log2(probability);
                    }
                });

                // Max entropy for uniform distribution
                const maxEntropy = Math.log2(gridResolution * gridResolution);

                // At low power, we lose information (higher entropy relative to our grid)
                const observerUncertainty = (100 - computationalBudget) / 100;
                entropy = entropy + (maxEntropy - entropy) * observerUncertainty;
            }

            document.getElementById('entropyValue').textContent = `H = ${entropy.toFixed(3)} bits`;

            // Heisenberg Uncertainty - REAL calculation from position/velocity variance
            let posVariance = 0;
            let velVariance = 0;

            if (particles.length > 1) {
                // Calculate mean position and velocity
                const meanX = particles.reduce((sum, p) => sum + p.x, 0) / particles.length;
                const meanY = particles.reduce((sum, p) => sum + p.y, 0) / particles.length;
                const meanVx = particles.reduce((sum, p) => sum + p.vx, 0) / particles.length;
                const meanVy = particles.reduce((sum, p) => sum + p.vy, 0) / particles.length;

                // Calculate variance (Δx)² and (Δp)²
                posVariance = particles.reduce((sum, p) => {
                    const dx = p.x - meanX;
                    const dy = p.y - meanY;
                    return sum + (dx * dx + dy * dy);
                }, 0) / particles.length;

                velVariance = particles.reduce((sum, p) => {
                    const dvx = p.vx - meanVx;
                    const dvy = p.vy - meanVy;
                    return sum + (dvx * dvx + dvy * dvy);
                }, 0) / particles.length;

                // At low observer power, we can't measure as precisely (increased uncertainty)
                const measurementError = 1 + (100 - computationalBudget) / 50;
                posVariance *= measurementError;
                velVariance *= measurementError;
            }

            // Δx · Δp (standard deviations multiplied)
            const uncertainty = Math.sqrt(posVariance) * Math.sqrt(velVariance);

            // Quantum vs classical difference
            const quantumFactor = currentObserver === 'quantum' ? 1.5 : 1.0;

            document.getElementById('uncertaintyValue').textContent = `Δx·Δp = ${(uncertainty * quantumFactor).toFixed(3)}`;

            // Network Density
            const maxConnections = particles.length * (particles.length - 1) / 2;
            const density = maxConnections > 0 ? connections.length / maxConnections : 0;
            document.getElementById('densityValue').textContent = `ρ = ${density.toFixed(3)}`;

            // Computational Cost
            const complexity = particles.length * particles.length;
            document.getElementById('complexityValue').textContent = `C = ${complexity.toLocaleString()} ops`;

            // Free Energy - REAL calculation based on system configuration
            // F = U - TS where U = potential energy, T = "temperature", S = entropy

            // Calculate potential energy from particle interactions
            let potentialEnergy = 0;
            // config already declared at top of function

            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Lennard-Jones-like potential: attractive at medium range, repulsive at close range
                    if (dist < config.connectionDistance) {
                        // Attractive term
                        potentialEnergy -= 1.0 / (dist + 1);
                    }
                    if (dist < 20) {
                        // Repulsive term at very close distances
                        potentialEnergy += 10.0 / (dist + 1);
                    }
                }
            }

            // Normalize by particle count
            potentialEnergy /= Math.max(1, particles.length);

            // Temperature proxy from kinetic energy (velocity variance)
            const kineticEnergy = particles.reduce((sum, p) => {
                return sum + (p.vx * p.vx + p.vy * p.vy);
            }, 0) / Math.max(1, particles.length);

            const temperature = Math.sqrt(kineticEnergy) * 0.1;

            // Free Energy: F = U - TS
            // Lower free energy = more stable, ordered system
            const freeEnergy = potentialEnergy - temperature * entropy * 0.01;

            document.getElementById('freeEnergyValue').textContent = `F = ${freeEnergy.toFixed(3)}`;

            // ===== NEW METRICS =====

            // Temperature (already calculated above)
            document.getElementById('temperatureValue').textContent = `T = ${temperature.toFixed(3)}`;

            // Update visual heat monitor
            const maxTemp = 2.0; // Reasonable max temperature for the bar
            const tempPercent = Math.min((temperature / maxTemp) * 100, 100);
            const heatBar = document.getElementById('heatBar');
            const heatValue = document.getElementById('heatValue');
            if (heatBar) {
                heatBar.style.width = tempPercent + '%';
                // Change glow intensity based on temperature
                heatBar.style.boxShadow = `0 0 ${10 + tempPercent * 0.3}px rgba(231,76,60,${0.3 + tempPercent * 0.007})`;
            }
            if (heatValue) {
                heatValue.textContent = `T = ${temperature.toFixed(3)}`;

                // Update unified monitor temp
                document.getElementById('tempDisplay').textContent = `T = ${temperature.toFixed(3)}`;
            }

            // Kinetic Energy (already calculated above)
            document.getElementById('kineticValue').textContent = `K = ${kineticEnergy.toFixed(3)}`;

            // Potential Energy (already calculated above)
            document.getElementById('potentialValue').textContent = `U = ${potentialEnergy.toFixed(3)}`;

            // Spatial Spread - RMS distance from center of mass
            let spatialSpread = 0;
            if (particles.length > 0) {
                // Calculate center of mass
                const centerX = particles.reduce((sum, p) => sum + p.x, 0) / particles.length;
                const centerY = particles.reduce((sum, p) => sum + p.y, 0) / particles.length;

                // Calculate RMS distance from center
                const sumSquaredDist = particles.reduce((sum, p) => {
                    const dx = p.x - centerX;
                    const dy = p.y - centerY;
                    return sum + (dx * dx + dy * dy);
                }, 0);

                spatialSpread = Math.sqrt(sumSquaredDist / particles.length);
            }
            document.getElementById('spatialSpreadValue').textContent = `σᵣ = ${spatialSpread.toFixed(3)}`;

            // Information Deficit - H_max - H (how far from maximum entropy)
            const gridResolution = Math.max(5, Math.floor(20 * (computationalBudget / 100)));
            const maxEntropy = Math.log2(gridResolution * gridResolution);
            const infoDeficit = maxEntropy - entropy;
            document.getElementById('infoDeficitValue').textContent = `ΔH = ${infoDeficit.toFixed(3)} bits`;

            // Average Velocity - mean speed
            let avgVelocity = 0;
            if (particles.length > 0) {
                const totalSpeed = particles.reduce((sum, p) => {
                    const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                    return sum + speed;
                }, 0);
                avgVelocity = totalSpeed / particles.length;
            }
            document.getElementById('avgVelocityValue').textContent = `⟨v⟩ = ${avgVelocity.toFixed(3)}`;

            // Total Energy = Kinetic + Potential (should be conserved!)
            const totalEnergy = (kineticEnergy * particles.length) + (potentialEnergy * particles.length);
            document.getElementById('totalEnergyValue').textContent = `E = ${totalEnergy.toFixed(3)}`;
        }

        // ===== UPDATE OBSERVER VISUALIZATION (keep particles, change view) =====
        function updateObserverVisualization() {
            const config = observerConfigs[currentObserver];
            const particles = window.currentParticles || [];

            if (particles.length === 0 || particles.length !== populationSize) {
                createReality();
                return;
            }

            // Update cluster assignments if switching to/from social
            if (currentObserver === 'social' && config.clusterCount) {
                const clusterColors = [
                    '#ff4757',  // BRIGHT RED tribe
                    '#3498db',  // BRIGHT BLUE tribe
                    '#2ecc71',  // BRIGHT GREEN tribe
                    '#ffa502',  // BRIGHT ORANGE tribe
                    '#9b59b6'   // BRIGHT PURPLE tribe
                ];
                particles.forEach(p => {
                    if (p.cluster === undefined) {
                        p.cluster = Math.floor(Math.random() * config.clusterCount);
                    }
                    // ASSIGN COLORS!
                    p.color = clusterColors[p.cluster % clusterColors.length];
                });
            }

            // Cancel old animation and restart with new observer
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            // Restart animation with new observer config
            startAnimation();
        }

        // ===== CANVAS SETUP =====
        let canvas, ctx, width, height;

        function initCanvas() {
            if (!canvas) {
                canvas = document.getElementById('reality-canvas');
                ctx = canvas.getContext('2d', { alpha: false }); // Opaque for better performance
            }

            // Set canvas size (can be called on resize)
            const container = canvas.parentElement;
            width = container.clientWidth;
            height = container.clientHeight;

            // Set canvas resolution to match display size
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            // Scale context to match device pixel ratio
            ctx.scale(dpr, dpr);

            // Store dimensions
            window.canvasWidth = width;
            window.canvasHeight = height;
        }

        // ===== REALITY VISUALIZATION =====
        function createReality() {
            const config = observerConfigs[currentObserver];

            // Initialize canvas if not done
            if (!canvas) {
                initCanvas();
            }

            // Create NEW particles based on population slider
            const particles = Array.from({length: populationSize}, (_, i) => ({
                id: i,
                x: Math.random() * width,
                y: Math.random() * height,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                cluster: observerConfigs[currentObserver].clusterCount ? Math.floor(Math.random() * observerConfigs[currentObserver].clusterCount) : 0,
                trail: [] // For classical observer trails
            }));

            // Store globally
            window.currentParticles = particles;

            // Start animation loop
            startAnimation();
        }

        // ===== CANVAS ANIMATION LOOP (GIGA SCALE OPTIMIZED!) =====
        function startAnimation() {
            const particles = window.currentParticles;
            if (!particles || particles.length === 0) return;

            const config = observerConfigs[currentObserver];
            const N = particles.length;

            // === LOD (LEVEL OF DETAIL) SYSTEM ===
            // Adaptive quality based on particle count for GIGA SCALE performance!
            const lod = {
                // Visual quality settings
                useGlow: N < 5000,              // Shadows/glow only under 5k
                useGhosts: N < 10000,           // Quantum ghosts only under 10k
                useTrails: N < 5000,            // Classical trails only under 5k
                particleSize: N < 10000 ? config.particleSize : Math.max(1, config.particleSize * 0.6),

                // Update frequencies (higher N = less frequent updates)
                connectionUpdateInterval: N < 5000 ? 1 : N < 20000 ? 3 : 5,
                mathPanelUpdateInterval: N < 10000 ? 30 : 60,

                // Drawing optimizations
                maxConnectionsDrawn: Math.min(2000, Math.floor(100000 / N) * 10),
                batchDrawConnections: N > 10000  // Batch connections for speed
            };

            // Setup quantum ghosts (LOD aware)
            if (currentObserver === 'quantum' && lod.useGhosts) {
                const ghosts = [];
                particles.forEach(p => {
                    for (let i = 0; i < 2; i++) {
                        const angle = (i / 2) * Math.PI * 2;
                        const radius = 20 + Math.random() * 15;
                        ghosts.push({
                            x: p.x + Math.cos(angle) * radius,
                            y: p.y + Math.sin(angle) * radius,
                            parent: p.id,
                            angle: angle,
                            radius: radius
                        });
                    }
                });
                window.ghostParticles = ghosts;
            }

            // Setup classical trails (LOD aware)
            if (currentObserver === 'classical' && lod.useTrails) {
                particles.forEach(p => {
                    if (!p.trail) p.trail = [{x: p.x, y: p.y}];
                });
            }

            // Setup social cluster colors - VIBRANT DISTINCT tribes!
            if (currentObserver === 'social') {
                const clusterColors = [
                    '#ff4757',  // BRIGHT RED tribe
                    '#3498db',  // BRIGHT BLUE tribe
                    '#2ecc71',  // BRIGHT GREEN tribe
                    '#ffa502',  // BRIGHT ORANGE tribe
                    '#9b59b6'   // BRIGHT PURPLE tribe
                ];
                particles.forEach(p => {
                    p.color = clusterColors[p.cluster % clusterColors.length];
                });
            }

            // Cancel old animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            let frameCount = 0;
            let cachedConnections = null; // Cache connections!

            // FPS tracking
            let lastFrameTime = performance.now();
            let frameTimes = [];

            // Update LOD status display
            const lodModeEl = document.getElementById('lodMode');
            const effectsActiveEl = document.getElementById('effectsActive');

            if (N < 5000) {
                lodModeEl.textContent = 'ULTRA';
                effectsActiveEl.textContent = 'ALL';
            } else if (N < 10000) {
                lodModeEl.textContent = 'HIGH';
                effectsActiveEl.textContent = 'NO GLOW';
            } else if (N < 20000) {
                lodModeEl.textContent = 'MEDIUM';
                effectsActiveEl.textContent = 'MINIMAL';
            } else {
                lodModeEl.textContent = 'FAST';
                effectsActiveEl.textContent = 'BATCH';
            }

            function animate() {
                // FPS calculation
                const now = performance.now();
                const delta = now - lastFrameTime;
                lastFrameTime = now;

                frameTimes.push(delta);
                if (frameTimes.length > 30) frameTimes.shift();

                if (frameCount % 10 === 0) {
                    const avgDelta = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
                    const fps = Math.round(1000 / avgDelta);
                    document.getElementById('fpsValue').textContent = fps;
                }
                // === THERMODYNAMIC EVOLUTION ===
                if (timeEvolutionActive) {
                    evolutionTime += evolutionSpeed * 0.01;

                    // Build spatial grid for O(N) force calculations
                    const forceRange = config.connectionDistance * 0.5;
                    const forceCellSize = forceRange;
                    const forceGrid = {};

                    particles.forEach(p => {
                        const cellX = Math.floor(p.x / forceCellSize);
                        const cellY = Math.floor(p.y / forceCellSize);
                        const cellKey = `${cellX},${cellY}`;
                        if (!forceGrid[cellKey]) forceGrid[cellKey] = [];
                        forceGrid[cellKey].push(p);
                    });

                    // Apply repulsive forces (entropy increase!)
                    particles.forEach(p => {
                        let fx = 0, fy = 0;
                        const cellX = Math.floor(p.x / forceCellSize);
                        const cellY = Math.floor(p.y / forceCellSize);

                        // Check 3x3 neighborhood only
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                const neighborKey = `${cellX + dx},${cellY + dy}`;
                                const neighbors = forceGrid[neighborKey] || [];

                                neighbors.forEach(other => {
                                    if (p.id !== other.id) {
                                        const deltaX = p.x - other.x;
                                        const deltaY = p.y - other.y;
                                        const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                                        if (dist < forceRange && dist > 0) {
                                            const force = 0.01 * evolutionSpeed / (dist + 1);
                                            fx += (deltaX / dist) * force;
                                            fy += (deltaY / dist) * force;
                                        }
                                    }
                                });
                            }
                        }

                        // Thermal noise
                        const thermalNoise = 0.02 * evolutionSpeed;
                        fx += (Math.random() - 0.5) * thermalNoise;
                        fy += (Math.random() - 0.5) * thermalNoise;

                        p.vx += fx;
                        p.vy += fy;

                        // Damping
                        p.vx *= 0.98;
                        p.vy *= 0.98;

                        // Cap velocity
                        const maxVel = 3;
                        const vel = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                        if (vel > maxVel) {
                            p.vx = (p.vx / vel) * maxVel;
                            p.vy = (p.vy / vel) * maxVel;
                        }
                    });
                }

                // === UPDATE POSITIONS ===
                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;

                    // Bounce
                    if (p.x < 0 || p.x > width) p.vx *= -1;
                    if (p.y < 0 || p.y > height) p.vy *= -1;

                    // Keep in bounds
                    p.x = Math.max(0, Math.min(width, p.x));
                    p.y = Math.max(0, Math.min(height, p.y));
                });

                // === CLEAR CANVAS ===
                ctx.fillStyle = '#0a0e27';
                ctx.fillRect(0, 0, width, height);

                // === DRAW CONNECTIONS (Cached for performance!) ===
                // Only recalculate connections every N frames (HUGE perf boost at giga scale!)
                if (!cachedConnections || frameCount % lod.connectionUpdateInterval === 0) {
                    cachedConnections = updateConnectionsData();
                }
                const links = cachedConnections.slice(0, lod.maxConnectionsDrawn);

                // Batch draw connections for better performance at high N
                if (lod.batchDrawConnections) {
                    // ULTRA FAST MODE: Single path for all connections
                    ctx.beginPath();
                    ctx.strokeStyle = config.color;
                    ctx.globalAlpha = 0.2;
                    ctx.lineWidth = 1;
                    links.forEach(link => {
                        ctx.moveTo(link.source.x, link.source.y);
                        ctx.lineTo(link.target.x, link.target.y);
                    });
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                } else {
                    // NORMAL MODE: Individual connections with observer effects
                    if (currentObserver === 'ai') {
                        // AI: Variable thickness by semantic distance
                        links.forEach(link => {
                            const strength = 1 - (link.distance / config.connectionDistance);
                            ctx.strokeStyle = config.color;
                            ctx.globalAlpha = (1 - link.distance / config.connectionDistance) * 0.5;
                            ctx.lineWidth = 0.5 + strength * 3;
                            ctx.beginPath();
                            ctx.moveTo(link.source.x, link.source.y);
                            ctx.lineTo(link.target.x, link.target.y);
                            ctx.stroke();
                        });
                        ctx.globalAlpha = 1;
                    } else if (currentObserver === 'social') {
                        // Social: Only same-cluster connections
                        const sameClusterLinks = links.filter(l => l.source.cluster === l.target.cluster);
                        sameClusterLinks.forEach(link => {
                            ctx.strokeStyle = link.source.color;
                            ctx.globalAlpha = 0.4;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(link.source.x, link.source.y);
                            ctx.lineTo(link.target.x, link.target.y);
                            ctx.stroke();
                        });
                        ctx.globalAlpha = 1;
                    } else {
                        // Default connections
                        ctx.lineWidth = 1;
                        links.forEach(link => {
                            ctx.strokeStyle = config.color;
                            ctx.globalAlpha = (1 - link.distance / config.connectionDistance) * 0.3;
                            ctx.beginPath();
                            ctx.moveTo(link.source.x, link.source.y);
                            ctx.lineTo(link.target.x, link.target.y);
                            ctx.stroke();
                        });
                        ctx.globalAlpha = 1;
                    }
                }

                // === DRAW CLASSICAL TRAILS (LOD aware) ===
                if (currentObserver === 'classical' && lod.useTrails) {
                    particles.forEach(p => {
                        if (!p.trail) p.trail = [];
                        p.trail.push({x: p.x, y: p.y});
                        if (p.trail.length > 20) p.trail.shift();

                        if (p.trail.length > 1) {
                            ctx.strokeStyle = config.color;
                            ctx.globalAlpha = 0.3;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(p.trail[0].x, p.trail[0].y);
                            for (let i = 1; i < p.trail.length; i++) {
                                ctx.lineTo(p.trail[i].x, p.trail[i].y);
                            }
                            ctx.stroke();
                            ctx.globalAlpha = 1;
                        }
                    });
                }

                // === DRAW QUANTUM GHOSTS (LOD aware) ===
                if (currentObserver === 'quantum' && lod.useGhosts && window.ghostParticles) {
                    window.ghostParticles.forEach((ghost, i) => {
                        const parent = particles[ghost.parent];
                        if (parent) {
                            // Ghosts orbit parent
                            const angle = ghost.angle + (frameCount * 0.02);
                            const radius = 20 + Math.sin(frameCount * 0.05 + i) * 12;
                            ghost.x = parent.x + Math.cos(angle) * radius;
                            ghost.y = parent.y + Math.sin(angle) * radius;
                        }

                        // Draw ghost with optional glow
                        const opacity = 0.35 + Math.sin(frameCount * 0.05) * 0.15;
                        const ghostSize = lod.particleSize * (1.0 + Math.sin(frameCount * 0.03) * 0.3);

                        ctx.globalAlpha = opacity;
                        ctx.fillStyle = config.color;
                        ctx.strokeStyle = config.color;
                        ctx.lineWidth = 1;

                        // Glow only at low particle counts
                        if (lod.useGlow) {
                            ctx.shadowColor = config.color;
                            ctx.shadowBlur = 8;
                        }

                        ctx.beginPath();
                        ctx.arc(ghost.x, ghost.y, ghostSize, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();

                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                    });
                }

                // === CALCULATE CONSCIOUS PREDICTION ERRORS ===
                if (currentObserver === 'conscious') {
                    particles.forEach(p => {
                        const expectedX = p.x + p.vx;
                        const expectedY = p.y + p.vy;
                        const actualX = p.x;
                        const actualY = p.y;
                        const error = Math.sqrt((expectedX - actualX)**2 + (expectedY - actualY)**2);
                        p.predictionError = error;
                    });
                }

                // === DRAW PARTICLES (LOD optimized + Observer Power) ===
                ctx.globalAlpha = 0.8;

                // Glow only at low particle counts (expensive!)
                if (lod.useGlow) {
                    ctx.shadowColor = config.color;
                    ctx.shadowBlur = 5;
                }

                // Observer Power coarse-graining
                const gridSize = computationalBudget < 100 ?
                    Math.max(5, Math.floor(50 - (computationalBudget / 100) * 45)) : 0;

                particles.forEach(p => {
                    let fillColor = config.color;

                    // Social: cluster colors
                    if (currentObserver === 'social') {
                        fillColor = p.color || config.color; // Fallback if color not set
                    }

                    // Conscious: error-based coloring
                    if (currentObserver === 'conscious') {
                        const errorIntensity = Math.min(p.predictionError / 5, 1);
                        fillColor = errorIntensity > 0.5 ? '#e74c3c' : config.color;
                    }

                    // Apply coarse-graining (quantization) if observer power < 100%
                    let drawX = p.x;
                    let drawY = p.y;
                    let drawSize = lod.particleSize;

                    if (gridSize > 0) {
                        // Snap to grid (coarse-grained observation)
                        drawX = Math.floor(p.x / gridSize) * gridSize + gridSize/2;
                        drawY = Math.floor(p.y / gridSize) * gridSize + gridSize/2;
                        drawSize = Math.max(3, gridSize / 8); // Bigger clusters at low power
                    }

                    ctx.fillStyle = fillColor;
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, drawSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Social: white stroke (always show for clarity!)
                    if (currentObserver === 'social') {
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;

                // === UPDATE MATH PANEL (Less frequently at high N) ===
                frameCount++;
                if (frameCount % lod.mathPanelUpdateInterval === 0) {
                    updateMathPanel();
                }

                animationFrameId = requestAnimationFrame(animate);
            }

            animate();
            updateMathPanel();
        }

        // ===== OLD SVG RENDERING (DEPRECATED - keeping for reference) =====
        function renderParticles(svg, particles, width, height) {
            const config = observerConfigs[currentObserver];

            // Draw connections
            const connections = svg.append('g').attr('class', 'connections');

            function updateConnections() {
                const links = updateConnectionsData();

                // === AI OBSERVER: Connection thickness by semantic distance ===
                if (currentObserver === 'ai') {
                    connections.selectAll('line')
                        .data(links, d => d.source.id + '-' + d.target.id)
                        .join('line')
                        .attr('class', 'connection')
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y)
                        .attr('stroke', config.color)
                        .attr('stroke-width', d => {
                            // Thicker lines = stronger semantic relationship (closer particles)
                            const strength = 1 - (d.distance / config.connectionDistance);
                            return 0.5 + strength * 3;
                        })
                        .attr('opacity', d => (1 - d.distance / config.connectionDistance) * 0.5);
                }
                // === SOCIAL OBSERVER: Only show same-cluster connections ===
                else if (currentObserver === 'social') {
                    const sameClusterLinks = links.filter(l => l.source.cluster === l.target.cluster);
                    connections.selectAll('line')
                        .data(sameClusterLinks, d => d.source.id + '-' + d.target.id)
                        .join('line')
                        .attr('class', 'connection')
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y)
                        .attr('stroke', d => d.source.color)
                        .attr('stroke-width', 2)
                        .attr('opacity', 0.4);
                }
                // === DEFAULT: Normal connections ===
                else {
                    connections.selectAll('line')
                        .data(links, d => d.source.id + '-' + d.target.id)
                        .join('line')
                        .attr('class', 'connection')
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y)
                        .attr('stroke', config.color)
                        .attr('stroke-width', 1)
                        .attr('opacity', d => (1 - d.distance / config.connectionDistance) * 0.3);
                }
            }

            // === QUANTUM OBSERVER: Add ghost particles (superpositions) ===
            if (currentObserver === 'quantum') {
                const ghostGroup = svg.append('g').attr('class', 'ghosts');

                // Create 2 ghost particles per real particle (superposition: HERE or THERE)
                const ghosts = [];
                particles.forEach(p => {
                    // Create ghosts at opposite positions (showing superposition)
                    for (let i = 0; i < 2; i++) {
                        const angle = (i / 2) * Math.PI * 2;
                        const radius = 20 + Math.random() * 15;
                        ghosts.push({
                            x: p.x + Math.cos(angle) * radius,
                            y: p.y + Math.sin(angle) * radius,
                            parent: p.id,
                            angle: angle
                        });
                    }
                });

                ghostGroup.selectAll('circle')
                    .data(ghosts)
                    .join('circle')
                    .attr('r', config.particleSize * 1.2)
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('fill', config.color)
                    .attr('opacity', 0.4)
                    .attr('stroke', config.color)
                    .attr('stroke-width', 1)
                    .style('filter', 'blur(1px) drop-shadow(0 0 8px ' + config.color + ')');

                // Store ghosts for animation
                window.ghostParticles = ghosts;
            }

            // === CLASSICAL OBSERVER: Add trajectory trails ===
            const trailGroup = svg.append('g').attr('class', 'trails');
            if (currentObserver === 'classical') {
                particles.forEach(p => {
                    p.trail = [{x: p.x, y: p.y}];
                });
            }

            // Draw particles
            const particleGroup = svg.append('g').attr('class', 'particles');

            // === SOCIAL OBSERVER: Color by cluster ===
            if (currentObserver === 'social') {
                // Assign cluster colors
                const clusterColors = ['#27ae60', '#2ecc71', '#16a085', '#1abc9c', '#229954'];
                particles.forEach(p => {
                    p.color = clusterColors[p.cluster % clusterColors.length];
                });
            }

            const particleElements = particleGroup.selectAll('circle')
                .data(particles)
                .join('circle')
                .attr('class', 'particle')
                .attr('r', config.particleSize)
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('fill', d => currentObserver === 'social' ? d.color : config.color)
                .attr('opacity', 0.8)
                .attr('stroke', currentObserver === 'social' ? 'white' : 'none')
                .attr('stroke-width', currentObserver === 'social' ? 1 : 0)
                .style('filter', 'drop-shadow(0 0 5px ' + config.color + ')');

            // Store connections globally
            window.currentConnections = [];

            // Cancel old animation loop if exists
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            // Animation loop
            let frameCount = 0;
            function animate() {
                // Thermodynamic time evolution - 2nd Law: Entropy increases
                if (timeEvolutionActive) {
                    evolutionTime += evolutionSpeed * 0.01;

                    // === OPTIMIZED FORCE CALCULATIONS with SPATIAL GRID ===
                    // Build spatial grid for O(N) force calculations instead of O(N²)
                    const forceRange = config.connectionDistance * 0.5;
                    const forceCellSize = forceRange;
                    const forceGrid = {};

                    particles.forEach(p => {
                        const cellX = Math.floor(p.x / forceCellSize);
                        const cellY = Math.floor(p.y / forceCellSize);
                        const cellKey = `${cellX},${cellY}`;

                        if (!forceGrid[cellKey]) forceGrid[cellKey] = [];
                        forceGrid[cellKey].push(p);
                    });

                    // Apply diffusion/spreading forces (particles repel, system becomes more disordered)
                    particles.forEach(p => {
                        let fx = 0, fy = 0;

                        const cellX = Math.floor(p.x / forceCellSize);
                        const cellY = Math.floor(p.y / forceCellSize);

                        // Check only nearby cells (3x3 neighborhood)
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                const neighborKey = `${cellX + dx},${cellY + dy}`;
                                const neighbors = forceGrid[neighborKey] || [];

                                neighbors.forEach(other => {
                                    if (p.id !== other.id) {
                                        const deltaX = p.x - other.x;
                                        const deltaY = p.y - other.y;
                                        const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                                        // Repulsive force - particles spread out
                                        if (dist < forceRange && dist > 0) {
                                            const force = 0.01 * evolutionSpeed / (dist + 1);
                                            fx += (deltaX / dist) * force;
                                            fy += (deltaY / dist) * force;
                                        }
                                    }
                                });
                            }
                        }

                        // Add random thermal motion (temperature)
                        const thermalNoise = 0.02 * evolutionSpeed;
                        fx += (Math.random() - 0.5) * thermalNoise;
                        fy += (Math.random() - 0.5) * thermalNoise;

                        // Apply forces
                        p.vx += fx;
                        p.vy += fy;

                        // Light damping to prevent runaway velocities
                        p.vx *= 0.98;
                        p.vy *= 0.98;

                        // Cap maximum velocity
                        const maxVel = 3;
                        const vel = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                        if (vel > maxVel) {
                            p.vx = (p.vx / vel) * maxVel;
                            p.vy = (p.vy / vel) * maxVel;
                        }
                    });
                }

                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;

                    // Bounce off edges
                    if (p.x < 0 || p.x > width) p.vx *= -1;
                    if (p.y < 0 || p.y > height) p.vy *= -1;

                    // Keep in bounds
                    p.x = Math.max(0, Math.min(width, p.x));
                    p.y = Math.max(0, Math.min(height, p.y));
                });

                particleElements
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                // === QUANTUM: Animate ghost particles ===
                if (currentObserver === 'quantum' && window.ghostParticles) {
                    window.ghostParticles.forEach((ghost, i) => {
                        const parent = particles[ghost.parent];
                        if (parent) {
                            // Ghosts orbit around parent with varying radius
                            const angle = ghost.angle + (frameCount * 0.02);
                            const radius = 20 + Math.sin(frameCount * 0.05 + i) * 12;
                            ghost.x = parent.x + Math.cos(angle) * radius;
                            ghost.y = parent.y + Math.sin(angle) * radius;
                        }
                    });

                    d3.selectAll('.ghosts circle')
                        .data(window.ghostParticles)
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y)
                        .attr('opacity', 0.35 + Math.sin(frameCount * 0.05) * 0.15)
                        .attr('r', d => config.particleSize * (1.0 + Math.sin(frameCount * 0.03) * 0.3));
                }

                // === CLASSICAL: Update trajectory trails ===
                if (currentObserver === 'classical') {
                    particles.forEach(p => {
                        if (!p.trail) p.trail = [];
                        p.trail.push({x: p.x, y: p.y});
                        if (p.trail.length > 20) p.trail.shift(); // Keep last 20 positions
                    });

                    // Draw trails
                    const allTrails = particles.filter(p => p.trail && p.trail.length > 1);
                    d3.select('.trails').selectAll('path')
                        .data(allTrails)
                        .join('path')
                        .attr('d', d => {
                            return d3.line()
                                .x(p => p.x)
                                .y(p => p.y)
                                .curve(d3.curveCardinal)(d.trail);
                        })
                        .attr('fill', 'none')
                        .attr('stroke', config.color)
                        .attr('stroke-width', 2)
                        .attr('opacity', 0.3);
                }

                // === CONSCIOUS: Show prediction errors as pulses ===
                if (currentObserver === 'conscious') {
                    particles.forEach(p => {
                        // Calculate prediction error (deviation from expected position)
                        const expectedX = p.x + p.vx;
                        const expectedY = p.y + p.vy;
                        const actualX = p.x;
                        const actualY = p.y;
                        const error = Math.sqrt((expectedX - actualX)**2 + (expectedY - actualY)**2);
                        p.predictionError = error;
                    });

                    // Color particles by error intensity
                    particleElements
                        .attr('fill', d => {
                            const errorIntensity = Math.min(d.predictionError / 5, 1);
                            return errorIntensity > 0.5 ? '#e74c3c' : config.color;
                        });
                }

                // === SOCIAL: Color by cluster ===
                if (currentObserver === 'social') {
                    particleElements.attr('fill', d => d.color);
                }

                updateConnections();

                // Update math panel every 30 frames (~0.5 seconds)
                frameCount++;
                if (frameCount % 30 === 0) {
                    updateMathPanel();
                }

                animationFrameId = requestAnimationFrame(animate);
            }

            animate();
            updateMathPanel();
        }

        // ===== TIME EVOLUTION =====
        function toggleTimeEvolution() {
            timeEvolutionActive = !timeEvolutionActive;
            const playBtn = document.getElementById('playBtn');
            const playIcon = document.getElementById('playIcon');
            const playText = document.getElementById('playText');

            if (timeEvolutionActive) {
                playBtn.style.background = '#e74c3c';
                playBtn.style.color = 'white';
                playIcon.textContent = '⏸️';
                playText.textContent = 'Pause';
            } else {
                playBtn.style.background = '#00ff88';
                playBtn.style.color = '#0a0e27';
                playIcon.textContent = '▶️';
                playText.textContent = 'Play';
            }
        }

        function updateSpeed(value) {
            evolutionSpeed = parseInt(value);
            document.getElementById('speedValue').textContent = value + 'x';
        }

        // ===== HEAT CONTROL =====
        function addHeat() {
            // Add heat = increase kinetic energy = increase particle velocities
            const particles = window.currentParticles || [];
            const heatFactor = 1.3; // 30% velocity increase

            particles.forEach(p => {
                p.vx *= heatFactor;
                p.vy *= heatFactor;
            });

            // Update calculations immediately
            updateMathPanel(true);

            // Show notification
            showNotification('🔥 Heat Added! Temperature & Entropy Increasing', '#e74c3c');
        }

        function removeHeat() {
            // Remove heat = decrease kinetic energy = decrease particle velocities
            const particles = window.currentParticles || [];
            const coolFactor = 0.7; // 30% velocity decrease

            particles.forEach(p => {
                p.vx *= coolFactor;
                p.vy *= coolFactor;
            });

            // Update calculations immediately
            updateMathPanel(true);

            // Show notification
            showNotification('❄️ System Cooled! Temperature Decreasing', '#3498db');
        }

        function showNotification(message, color) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: ${color};
                color: white;
                padding: 20px 40px;
                border-radius: 12px;
                font-size: 1.2em;
                font-weight: 700;
                z-index: 10000;
                box-shadow: 0 0 40px ${color};
                animation: pulse 0.5s ease-out;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 1500);
        }

        // ===== POPULATION CONTROL =====
        function updatePopulation(value) {
            populationSize = parseInt(value);
            document.getElementById('populationValue').textContent = value;

            // Update unified monitor
            document.getElementById('popDisplay').textContent = value;

            // Recreate reality with new population
            createReality();

            // Show cascade effect
            setTimeout(() => updateMathPanel(true), 300);
        }

        // Update connections and store for math calculations
        // OPTIMIZED with spatial grid partitioning!
        function updateConnectionsData() {
            const particles = window.currentParticles || [];
            const config = observerConfigs[currentObserver];
            const links = [];

            // MAX CONNECTIONS to prevent lag at high N
            const MAX_CONNECTIONS = 2000;

            // === SPATIAL GRID OPTIMIZATION ===
            // Only check particles in nearby grid cells (O(N) instead of O(N²)!)
            const cellSize = config.connectionDistance;
            const canvasWidth = window.canvasWidth || 1200;
            const canvasHeight = window.canvasHeight || 800;
            const grid = {};

            // Assign particles to grid cells
            particles.forEach(p => {
                const cellX = Math.floor(p.x / cellSize);
                const cellY = Math.floor(p.y / cellSize);
                const cellKey = `${cellX},${cellY}`;

                if (!grid[cellKey]) grid[cellKey] = [];
                grid[cellKey].push(p);
            });

            // Check each particle only against nearby cells (3x3 neighborhood)
            particles.forEach(p => {
                const cellX = Math.floor(p.x / cellSize);
                const cellY = Math.floor(p.y / cellSize);

                // Check 9 nearby cells (including current)
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const neighborKey = `${cellX + dx},${cellY + dy}`;
                        const neighbors = grid[neighborKey] || [];

                        neighbors.forEach(neighbor => {
                            // Avoid duplicate connections
                            if (p.id < neighbor.id) {
                                const deltaX = p.x - neighbor.x;
                                const deltaY = p.y - neighbor.y;
                                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                                if (distance < config.connectionDistance && distance > 0) {
                                    links.push({
                                        source: p,
                                        target: neighbor,
                                        distance: distance
                                    });

                                    // Stop if we hit max connections (prevent lag)
                                    if (links.length >= MAX_CONNECTIONS) return;
                                }
                            }
                        });

                        if (links.length >= MAX_CONNECTIONS) break;
                    }
                    if (links.length >= MAX_CONNECTIONS) break;
                }
            });

            window.currentConnections = links;
            return links;
        }

        // ===== TOOLTIP CLICK HANDLERS =====
        document.addEventListener('click', function(e) {
            // Close all tooltips first
            if (!e.target.closest('.tooltip-icon') && !e.target.closest('.stat-row-hover')) {
                document.querySelectorAll('.tooltip-icon.active').forEach(el => el.classList.remove('active'));
                document.querySelectorAll('.stat-row-hover.active').forEach(el => el.classList.remove('active'));
            }

            // Toggle tooltip on click
            if (e.target.closest('.tooltip-icon')) {
                e.stopPropagation();
                const tooltip = e.target.closest('.tooltip-icon');
                tooltip.classList.toggle('active');
            }

            // Toggle stat tooltip on click
            if (e.target.closest('.stat-row-hover')) {
                e.stopPropagation();
                const statRow = e.target.closest('.stat-row-hover');
                statRow.classList.toggle('active');
            }
        });

        // ===== INITIALIZATION =====
        window.addEventListener('resize', createReality);
        createReality();
    </script>
</body>
</html>
